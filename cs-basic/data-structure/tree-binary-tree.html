<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.73" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://github.com/amatureemoprince/cs-basic/data-structure/tree-binary-tree.html"><meta property="og:site_name" content="Java咖啡馆"><meta property="og:title" content="树"><meta property="og:description" content="树的定义 定义：是n(n≥0)个节点的有限集。当n = 0时，称为空树。在任意一颗非空树中应满足： 有且仅有一个特定的称为根的结点。 当n > 1时，其余节点可分为m(m > 0)个互不相交的树，并称其为子树。 根据上面树的定义可以知道：树是递归的，树中有包含树；树是一种逻辑结构和分层结构。 并且树的根节点是没有前驱的，除根节点外，其余所有节点有且仅有..."><meta property="og:type" content="article"><meta property="og:image" content="https://camo.githubusercontent.com/10c7c080594f09e22acc36e1b73f9bba2fd8727014cccdea357a41a33f64a7b3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313532383537323234332d63343865656666632d373732352d343837612d613531392d3831303665393566373535622e706e67"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-03-26T00:41:32.000Z"><meta property="article:modified_time" content="2025-03-26T00:41:32.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"树","image":["https://camo.githubusercontent.com/10c7c080594f09e22acc36e1b73f9bba2fd8727014cccdea357a41a33f64a7b3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313532383537323234332d63343865656666632d373732352d343837612d613531392d3831303665393566373535622e706e67","https://camo.githubusercontent.com/36b10699d6ee0cc12f3e75bc6aaaa939ded16700de384d2925165227e27bab63/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313837313430353331342d33353638656134392d353361362d346435372d383564352d6531393336323833313433612e706e67","https://camo.githubusercontent.com/41767293e006e705ceb89ed493ac6c0adb9a704df299e572949c4bf7febce872/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f776562702f34383037333733302f313734313837313630313739322d64353162653966392d343338352d343734662d396432652d3261353332666263366366622e77656270","https://camo.githubusercontent.com/f3050ee54e6a13d45ff3ed62e54df92b63261e822b78428a29d362db5ac827b4/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313837313731363138372d63376464653636612d343264302d343539312d383665652d3464323439396265376533622e706e67","https://camo.githubusercontent.com/6698c05fe617d9ed9c5e902023e3bf3ce1ffcba9169ccb34e202dd2f22bc5b01/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323236333736373634302d36313736396463342d323337642d343634372d383062362d3064303436353164666465332e6a706567","https://camo.githubusercontent.com/5b617deeb57e83f87af2c97aa589e0cfd01a4a6c18b4c5f37dacde2ac15b2dec/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313539303236393738392d32366566663464322d353432642d346232652d623634342d3964336264613330376131352e706e67","https://camo.githubusercontent.com/9a0bba2fbe2e2ac6f2be40efe5b3597cb9a866902d332c41dd9de7f6b906f3be/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313631333632333833382d63333566616635372d666663382d343535342d613736382d3030396338663664643834372e706e67","https://camo.githubusercontent.com/2031900f42335021fd166b432fb27d89940d1b938216701fd48e8e48b00cd230/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313631333534363733372d65633539353839372d323439632d346435362d613264612d6134383335343561333263622e706e67","https://camo.githubusercontent.com/ecfc61d5e0efb006a3e33019a1168083b083da7b414a619da376ee1ae9a83bf8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313636323336393730362d30383562653930362d373361622d346566342d616265372d3838643633363563626461352e706e67","https://camo.githubusercontent.com/9e859e65b4f81ea4fec07dc57e7abda83658b2015b07c0eddeed0a0cd2e0fcff/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313636323630333038312d61353831363562612d643535372d346165622d393137632d6237313563623534636463642e706e67","https://camo.githubusercontent.com/b4332f67d3c5c99e2400d865ce58c899a3ce384ec7c15fbbe9f9f799546d1bf7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313636323737303933332d61643261363538332d663564382d343039662d626339322d3837336531653266323438332e706e67","https://camo.githubusercontent.com/47399eeb184c2238ca28be1beb038e609a6fe1aa1b476a2ec348626ead45be2b/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734313736313631373339372d33336466376337362d396138362d346661382d396333332d6564626664336563316165382e6a7065673f782d6f73732d70726f636573733d696d6167652f6175746f2d6f7269656e742c31","https://camo.githubusercontent.com/45cc0853b453b95b82f7901f1e394ba59c1caca072d77bc70fdcb1dcaed1c314/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313736323236353433352d37613632376233632d626664342d346263612d616661322d3439646337353639326262302e706e67","https://camo.githubusercontent.com/9e2c7fc752814d006de2644ee72b27e6dde8393797a406e51f966d68a7a0f576/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734313932323339313138352d31323739663762322d323963342d346339382d383336642d6638613266306330316532342e6a706567","https://camo.githubusercontent.com/8075e301cdfe4ba6eff98d01a0fef39261fb76a494a0df2829ca4b9f22b45403/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323238343536383330382d36653130396262612d376439662d346561632d613938642d3239303830373261396630342e6a706567","https://camo.githubusercontent.com/ed0bb9478e2cddf52c665d796f0c3b71023f09093941c0db2887fa1cf7a5098b/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323238373035373832332d64626664623932342d626234362d343261352d386639332d3232356665343235313162302e6a706567"],"dateModified":"2025-03-26T00:41:32.000Z","author":[{"@type":"Person","name":"阿杰 like coding bug ❥","url":"https://mister-hope.com"}]}</script><link rel="icon" href="/favicon.ico"><meta name="baidu-site-verification" content="codeva-EW7fPgf7Zs"><title>树 | Java咖啡馆</title><meta name="description" content="树的定义 定义：是n(n≥0)个节点的有限集。当n = 0时，称为空树。在任意一颗非空树中应满足： 有且仅有一个特定的称为根的结点。 当n > 1时，其余节点可分为m(m > 0)个互不相交的树，并称其为子树。 根据上面树的定义可以知道：树是递归的，树中有包含树；树是一种逻辑结构和分层结构。 并且树的根节点是没有前驱的，除根节点外，其余所有节点有且仅有...">
    <link rel="stylesheet" href="/assets/css/styles.e3031f62.css">
    <link rel="preload" href="/assets/js/runtime~app.ec5fa5f3.js" as="script"><link rel="preload" href="/assets/css/styles.e3031f62.css" as="style"><link rel="preload" href="/assets/js/1935.4522daaa.js" as="script"><link rel="preload" href="/assets/js/app.11fa9fe8.js" as="script">
    <link rel="prefetch" href="/assets/js/cs-basic_data-structure_tree-binary-tree.html.b6996370.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_data-structure_stack-queue-array.html.00ea5e7a.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_data-structure_graph.html.3713c267.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_data-structure_linear-list.html.7931a22d.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_data-structure_time-and-space-complexity.html.ee77c594.js" as="script"><link rel="prefetch" href="/assets/js/8300.e1ce851e.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_data-structure_string.html.77f4047a.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_data-structure_sort-algorithm.html.1bd63d02.js" as="script"><link rel="prefetch" href="/assets/js/java-coffee_about-java-coffee.html.3831006f.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_data-structure_index.html.d0bc20ba.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_data-structure_search-algorithm.html.b46bf4d2.js" as="script"><link rel="prefetch" href="/assets/js/java-coffee_index.html.0254574c.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_index.html.5efd1706.js" as="script"><link rel="prefetch" href="/assets/js/index.html.b807833a.js" as="script"><link rel="prefetch" href="/assets/js/java-coffee_use-java-coffee-suggestions.html.a2f6c875.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_network-layer_the-two-services.html.3463db2b.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_transport-layer_tcp-transmission-control-protocol.html.5993c8ff.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_transport-layer_udp-user-datagram-protocol.html.06e92db6.js" as="script"><link rel="prefetch" href="/assets/js/read-book-thinking_index.html.73f6a96d.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_preface_computer-network-details.html.30dc4b29.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_preface_first-introduction-to-computer-networks.html.d6e7398e.js" as="script"><link rel="prefetch" href="/assets/js/about-the-author_index.html.4987bf4c.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_transport-layer_overview.html.103a3f5e.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_network-layer_overview.html.61ec3bb6.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_physical-layer_overview.html.d2016c3e.js" as="script"><link rel="prefetch" href="/assets/js/week-update_index.html.9903f3f3.js" as="script"><link rel="prefetch" href="/assets/js/java-coffee_contribution-java-coffee.html.8d7976e5.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_index.html.cf8f3b93.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_operating-system_REANDME.html.9dc40a23.js" as="script"><link rel="prefetch" href="/assets/js/java_index.html.6d7fb5a9.js" as="script"><link rel="prefetch" href="/assets/js/category_栈、队列、数组_index.html.b831bb25.js" as="script"><link rel="prefetch" href="/assets/js/category_周周新鲜事_index.html.3db00a8d.js" as="script"><link rel="prefetch" href="/assets/js/category_计算机网络_index.html.6e781070.js" as="script"><link rel="prefetch" href="/assets/js/category_有趣实验_index.html.7687c17a.js" as="script"><link rel="prefetch" href="/assets/js/category_查找算法_index.html.d0db8780.js" as="script"><link rel="prefetch" href="/assets/js/category_神奇动物_index.html.7b8fd0f7.js" as="script"><link rel="prefetch" href="/assets/js/category_线性结构_index.html.26c2e80c.js" as="script"><link rel="prefetch" href="/assets/js/category_排序算法_index.html.27966cf0.js" as="script"><link rel="prefetch" href="/assets/js/category_数据结构_index.html.dc2d1fad.js" as="script"><link rel="prefetch" href="/assets/js/tag_走进项目_index.html.867e39f7.js" as="script"><link rel="prefetch" href="/assets/js/category_国内外_index.html.55838097.js" as="script"><link rel="prefetch" href="/assets/js/category_新技术_index.html.747f79a2.js" as="script"><link rel="prefetch" href="/assets/js/category_传输层_index.html.b5a01fb6.js" as="script"><link rel="prefetch" href="/assets/js/category_网络层_index.html.9f2d2efb.js" as="script"><link rel="prefetch" href="/assets/js/category_引言_index.html.b2af812d.js" as="script"><link rel="prefetch" href="/assets/js/category_算法_index.html.c06742e3.js" as="script"><link rel="prefetch" href="/assets/js/category_概述_index.html.59ed52ba.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_transport-layer_index.html.632801e3.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_physical-layer_index.html.aa6f8e0e.js" as="script"><link rel="prefetch" href="/assets/js/category_串_index.html.a1c03eb5.js" as="script"><link rel="prefetch" href="/assets/js/category_图_index.html.ecec6287.js" as="script"><link rel="prefetch" href="/assets/js/category_树_index.html.74f7f15d.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_network-layer_index.html.641e7ee1.js" as="script"><link rel="prefetch" href="/assets/js/tag_o(n)~_index.html.a6fcb39c.js" as="script"><link rel="prefetch" href="/assets/js/category_408_index.html.3ca44184.js" as="script"><link rel="prefetch" href="/assets/js/category_tcp_index.html.3ad78221.js" as="script"><link rel="prefetch" href="/assets/js/category_udp_index.html.7bcd305a.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_operating-system_index.html.5cfd03e4.js" as="script"><link rel="prefetch" href="/assets/js/404.html.fb687d49.js" as="script"><link rel="prefetch" href="/assets/js/cs-basic_computer-network_preface_index.html.c3e139bf.js" as="script"><link rel="prefetch" href="/assets/js/timeline_index.html.56151bf0.js" as="script"><link rel="prefetch" href="/assets/js/category_index.html.48e2c29a.js" as="script"><link rel="prefetch" href="/assets/js/article_index.html.ddcc306e.js" as="script"><link rel="prefetch" href="/assets/js/tag_index.html.db5d63f6.js" as="script"><link rel="prefetch" href="/assets/js/star_index.html.0c55785a.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container external-link-icon pure has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="带我回家"><img class="vp-nav-logo" src="/favicon.ico" alt><!----><span class="vp-site-name hide-in-pad">Java咖啡馆</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="首页" iconsizing="height"><!--[--><i class="vp-icon fas fa-bookmark" sizing="height"></i><!--]-->首页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/java-coffee/" aria-label="使用指南" iconsizing="height"><!--[--><i class="vp-icon fas fa-compass" sizing="height"></i><!--]-->使用指南<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/java/" aria-label="Java 生态圈" iconsizing="height"><!--[--><i class="vp-icon fas fa-laptop-code" sizing="height"></i><!--]-->Java 生态圈<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/cs-basic/" aria-label="计算机基础" iconsizing="height"><!--[--><i class="vp-icon fas fa-book-open" sizing="height"></i><!--]-->计算机基础<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/read-book-thinking/" aria-label="笔隙杂谈" iconsizing="height"><!--[--><i class="vp-icon fas fa-feather" sizing="height"></i><!--]-->笔隙杂谈<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/week-update/" aria-label="周周新鲜事" iconsizing="height"><!--[--><i class="vp-icon fas fa-lightbulb" sizing="height"></i><!--]-->周周新鲜事<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="网站相关"><!--[--><i class="vp-icon fas fa-users" sizing="height"></i>网站相关<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/article/" aria-label="查看历史" iconsizing="both"><!--[--><i class="vp-icon fas fa-book fa-fw" sizing="both"></i><!--]-->查看历史<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/about-the-author/" aria-label="关于作者" iconsizing="both"><!--[--><i class="vp-icon fas fa-user fa-fw" sizing="both"></i><!--]-->关于作者<!----></a></li></ul></button></div></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/amatureemoprince" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><i class="vp-icon fas fa-network-wired fa-fw" sizing="both"></i><span class="vp-sidebar-title">计算机网络</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">前言</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/computer-network/preface/first-introduction-to-computer-networks.html" aria-label="初始计算机网络" iconsizing="both"><!--[--><i class="vp-icon fas fa-star-of-life fa-fw" sizing="both"></i><!--]-->初始计算机网络<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/computer-network/preface/computer-network-details.html" aria-label="计算机网络的各种“细节”" iconsizing="both"><!--[--><i class="vp-icon fas fa-info fa-fw" sizing="both"></i><!--]-->计算机网络的各种“细节”<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">物理层</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/computer-network/physical-layer/overview.html" aria-label="物理层概述" iconsizing="both"><!--[--><i class="vp-icon fas fa-plant-wilt fa-fw" sizing="both"></i><!--]-->物理层概述<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">网络层</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/computer-network/network-layer/overview.html" aria-label="网络层概述" iconsizing="both"><!--[--><i class="vp-icon fas fa-paperclip fa-fw" sizing="both"></i><!--]-->网络层概述<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/computer-network/network-layer/the-two-services.html" aria-label="网络层提供的服务" iconsizing="both"><!--[--><i class="vp-icon fas fa-inbox fa-fw" sizing="both"></i><!--]-->网络层提供的服务<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">传输层</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/computer-network/transport-layer/overview.html" aria-label="传输层概述" iconsizing="both"><!--[--><i class="vp-icon fas fa-truck fa-fw" sizing="both"></i><!--]-->传输层概述<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/computer-network/transport-layer/udp-user-datagram-protocol.html" aria-label="用户数据报协议——UDP" iconsizing="both"><!--[--><i class="vp-icon fas fa-truck-fast fa-fw" sizing="both"></i><!--]-->用户数据报协议——UDP<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/computer-network/transport-layer/tcp-transmission-control-protocol.html" aria-label="传输控制协议——TCP" iconsizing="both"><!--[--><i class="vp-icon fas fa-shield-halved fa-fw" sizing="both"></i><!--]-->传输控制协议——TCP<!----></a></li></ul></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><i class="vp-icon fas fa-folder-tree fa-fw" sizing="both"></i><span class="vp-sidebar-title">数据结构</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/data-structure/" aria-label="引言" iconsizing="both"><!--[--><i class="vp-icon fas fa-star-of-life fa-fw" sizing="both"></i><!--]-->引言<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/data-structure/time-and-space-complexity.html" aria-label="评判算法好坏的标准" iconsizing="both"><!--[--><i class="vp-icon fas fa-bugs fa-fw" sizing="both"></i><!--]-->评判算法好坏的标准<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/data-structure/linear-list.html" aria-label="线性表" iconsizing="both"><!--[--><i class="vp-icon fas fa-water fa-fw" sizing="both"></i><!--]-->线性表<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/data-structure/stack-queue-array.html" aria-label="栈、队列和数组" iconsizing="both"><!--[--><i class="vp-icon fas fa-hands-bubbles fa-fw" sizing="both"></i><!--]-->栈、队列和数组<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/data-structure/string.html" aria-label="串" iconsizing="both"><!--[--><i class="vp-icon fas fa-paper-plane fa-fw" sizing="both"></i><!--]-->串<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/cs-basic/data-structure/tree-binary-tree.html" aria-label="树" iconsizing="both"><!--[--><i class="vp-icon fas fa-tree fa-fw" sizing="both"></i><!--]-->树<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/data-structure/graph.html" aria-label="图" iconsizing="both"><!--[--><i class="vp-icon fas fa-image fa-fw" sizing="both"></i><!--]-->图<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/data-structure/search-algorithm.html" aria-label="查找算法" iconsizing="both"><!--[--><i class="vp-icon fas fa-magnifying-glass fa-fw" sizing="both"></i><!--]-->查找算法<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cs-basic/data-structure/sort-algorithm.html" aria-label="排序算法" iconsizing="both"><!--[--><i class="vp-icon fas fa-sort fa-fw" sizing="both"></i><!--]-->排序算法<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><i class="vp-icon fas fa-computer fa-fw" sizing="both"></i><span class="vp-sidebar-title">计算机组成原理</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><i class="vp-icon fas fa-solid fa-laptop fa-fw" sizing="both"></i><span class="vp-sidebar-title">操作系统</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><i class="vp-icon fas fa-tree" sizing="height"></i>树</h1><div class="page-info"><span class="page-author-info" aria-label="作者"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://mister-hope.com" target="_blank" rel="noopener noreferrer">阿杰 like coding bug ❥</a></span><span property="author" content="阿杰 like coding bug ❥"></span></span><span class="page-category-info" aria-label="分类"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item clickable" role="navigation">408</span><span class="page-category-item clickable" role="navigation">数据结构</span><span class="page-category-item clickable" role="navigation">树</span><!--]--><meta property="articleSection" content="408,数据结构,树"></span><!----><!----><span class="page-word-info" aria-label="字数"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon" name="word"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 6545 字</span><meta property="wordCount" content="6545"></span><span class="page-reading-time-info" aria-label="阅读时间"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 22 分钟</span><meta property="timeRequired" content="PT22M"></span><!----></div><hr></div><!----><!----><div class="theme-hope-content" vp-content><h2 id="树的定义" tabindex="-1"><a class="header-anchor" href="#树的定义"><span><strong>树的定义</strong></span></a></h2><blockquote><p>定义：是n(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>)个节点的<strong>有限集</strong>。当n = 0时，称为空树。在任意一颗非空树中应满足：</p><ol><li>有且仅有一个特定的称为<strong>根</strong>的结点。</li><li>当n &gt; 1时，其余节点可分为m(m &gt; 0)个互不相交的树，并称其为<strong>子树</strong>。</li></ol></blockquote><p>根据上面树的定义可以知道：树是递归的，树中有包含树；<strong>树是一种逻辑结构和分层结构</strong>。</p><p>并且树的根节点是没有前驱的，除根节点外，其余所有节点有且仅有一个前驱（双亲），但是树中的每个节点可以有0个或多个后继（孩子）。</p><figure><img src="https://camo.githubusercontent.com/10c7c080594f09e22acc36e1b73f9bba2fd8727014cccdea357a41a33f64a7b3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313532383537323234332d63343865656666632d373732352d343837612d613531392d3831303665393566373535622e706e67" alt="树的示意图" tabindex="0" loading="lazy"><figcaption>树的示意图</figcaption></figure><h2 id="基本术语" tabindex="-1"><a class="header-anchor" href="#基本术语"><span><strong>基本术语</strong></span></a></h2><p>我们需要知道关于树的一些专业术语。</p><ul><li>祖先：使用D节点举例，A到D的唯一路径上除了D的所有的节点全为D的祖先节点。</li><li>子孙：一个节点下的所有子树上的节点都为其子孙，如：D、E、F为C的子孙。</li><li>双亲：根节点到该节点路径上离该节点最近的节点，如：C就为D的双亲，也为E、F的双亲。</li><li>孩子：和双亲类似，D、E、F都为C的孩子，只有根节点没有双亲。</li><li>兄弟：有相同双亲的节点称为兄弟节点。</li><li>堂兄弟：双亲在同一层的结点称为堂兄弟，如：C、G、I为堂兄弟。</li><li>节点的层次：如上面的图，根节点在第一层，往下层数依次增加。</li><li>节点的深度：就是节点的层次。</li><li>树的高度（深度）：树中节点的最大层数。</li><li>节点的高度：是以该节点为根节点的子树高度。</li><li>节点的度：有几个孩子节点，度就为多少。</li><li>树的度：树中节点的最大的度为树的度。</li><li>分支节点：度大于0的节点。</li><li>叶节点：度为0的节点。</li><li>有序树：树中节点的各子树从做到右是有次序的，不能互换。</li><li>无序树：就和上面相反呗，无序并可以相互交换（仅在有一个以上孩子节点时成立）。</li><li>路径：树中两个节点之间的路径是由这两个节点之间所经过的节点序列组成的。</li><li>路径长度：是整个路径上边的条数。</li></ul><h2 id="森林" tabindex="-1"><a class="header-anchor" href="#森林"><span><strong>森林</strong></span></a></h2><blockquote><p>定义：是m(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>)颗互不相交的树的集合。</p></blockquote><p>树和森林在现实生活中是包含关系。在数据结构中也很类似，给m颗树形成的森林加上一个节点，并把这m颗树作为该节点的子树，则森林就变为了树；而树去掉根节点又可以变为森林。</p><h2 id="树的性质" tabindex="-1"><a class="header-anchor" href="#树的性质"><span><strong>树的性质</strong></span></a></h2><p>在树中最重要的就是节点、度数、高度之间的关系了，所以我们来学习这些性质。</p><p><strong>1. 树的节点数n等于所有节点的度数之和加一</strong>：所有的度数之和就是除了根节点之外所有节点之和，所以在此基础上加一就可以得到树的节点数n了。</p><p><strong>2. 度为m的树中第i层上之多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">m^{i - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个节点(i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>)</strong>：因为条件是之多，故只要每个节点的度都为m，这样在在第i层的结点数就最多。</p><p><strong>3. 高度为h的m叉树至多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{m^h - 1}{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4463em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0429em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.927em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个节点</strong>：根据等比数列的前n项和公式可以轻松得到这个结论。</p><p><strong>4. 度为m、具有n个节点的树的最小高度h为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[log_m(n(m - 1)) + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>(注意是需要向上取整的)</strong>：因为要求是最小的高度，所以在最后一层之上的每个节点的度都要为m，设树的高度为h，前h - 1层最多有 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msup><mi>m</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{m^{h - 1}}{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4463em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0429em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.927em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></strong> 个节点，前n层最多有 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msup><mi>m</mi><mi>h</mi></msup><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{m^h}{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4463em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0429em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.927em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></strong> 个节点，并且要满足 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msup><mi>m</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mfrac><msup><mi>m</mi><mi>h</mi></msup><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{m^{h - 1}}{m - 1} &lt; n \leq \frac{m^h}{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4463em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0429em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.927em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4463em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0429em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.927em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></strong>，根据这个不等式可得最终结果。</p><p><strong>5. 度为m、具有n个节点的树的最大高度h为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - m + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong>：条件为h最高，则满足在上部分为两两节点连接，只在两两节点相连的最后一个节点实现度为m。</p><h2 id="树的存储结构" tabindex="-1"><a class="header-anchor" href="#树的存储结构"><span><strong>树的存储结构</strong></span></a></h2><p>树的存储可以采用顺序存储结构也可以采用链式存储结构。<strong>但无论采用的是什么结构，都要能唯一地反映树中各个节点之间的逻辑关系。</strong>（哪个节点是哪个节点的双亲，哪个节点是哪个节点的孩子）</p><p>我们学习三种表示方式：</p><h3 id="_1-双亲表示法" tabindex="-1"><a class="header-anchor" href="#_1-双亲表示法"><span><strong>1. 双亲表示法</strong></span></a></h3><p>这种表示的方法整体上是采用的顺序存储，但补充了一些细节。<strong>顺序存储中的每个节点中增加一个伪指针parent，用于指向双亲在数组中的索引，根节点的伪指针指向-1则可。</strong></p><p>显而易见的，这种方式可以轻松地获取到双亲节点，但要获取孩子节点就不容易了，需要遍历整个数组才能得到。（要找双亲节点索引为2的节点就得遍历整个数组去找伪指针为2的节点）。</p><p>节点C语言结构体表示为：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MAX_SIZE</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//声明节点结构</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> PTreeNode{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> parent;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}PTreeNode;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//一棵树</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> PTree{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    PTreeNode </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">nodes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[MAX_SIZE];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //树中节点的个数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}PTree;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://camo.githubusercontent.com/36b10699d6ee0cc12f3e75bc6aaaa939ded16700de384d2925165227e27bab63/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313837313430353331342d33353638656134392d353361362d346435372d383564352d6531393336323833313433612e706e67" alt="双亲表示法示意图" tabindex="0" loading="lazy"><figcaption>双亲表示法示意图</figcaption></figure><h3 id="_2-孩子表示法" tabindex="-1"><a class="header-anchor" href="#_2-孩子表示法"><span><strong>2. 孩子表示法</strong></span></a></h3><p>在整体上采用的是链式存储结构（单链表），<strong>一颗树有n个节点那么这个单链表就会有n个孩子链表。每个孩子链表的头指针一起组成了一个线性表，为了便于查找，这些头指针采用顺序存储结构。</strong></p><p>每条孩子链表中节点都为顺序表中对应节点在树中的孩子节点。</p><p>这个虽然可以很好地获取到孩子节点，但是找双亲就困难了，需要遍历所有节点中的链表。</p><p>C语言定义结构体为（我直接定义数据类型为int）：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 定义孩子节点的结构体</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ChildNode {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> childIndex;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 孩子节点的索引</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ChildNode</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> next;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 指向下一个孩子节点的指针</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} ChildNode;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 定义树节点的结构体</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TreeNode {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                      // 节点的数据</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ChildNode</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> children;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           // 指向孩子链表的头指针</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} TreeNode;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 定义树的结构体</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Tree {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    TreeNode</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nodes;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               // 节点数组</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> size;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                      // 节点总数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} Tree;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://camo.githubusercontent.com/41767293e006e705ceb89ed493ac6c0adb9a704df299e572949c4bf7febce872/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f776562702f34383037333733302f313734313837313630313739322d64353162653966392d343338352d343734662d396432652d3261353332666263366366622e77656270" alt="孩子表示法示意图" tabindex="0" loading="lazy"><figcaption>孩子表示法示意图</figcaption></figure><h3 id="_3-孩子兄弟表示法" tabindex="-1"><a class="header-anchor" href="#_3-孩子兄弟表示法"><span><strong>3. 孩子兄弟表示法</strong></span></a></h3><p>这个方法又可以被称为<strong>二叉树表示法</strong>，因为其可以将树转换为二叉链表树。每个节点包含3个值，分别为<strong>指向孩子的指针、节点值、指向下一个兄弟的指针</strong>。</p><p>这样转化的二叉树中的一个非叶子节点A的左孩子B就为在原树中A的第一个孩子B，二叉树中B的右孩子就为原树B的相邻右兄弟，以此类推。这就是所谓的<strong>左孩子右兄弟</strong>。</p><p>此方法最大的优点就是<strong>可以方便地将树转换为二叉树，轻松地得到节点的孩子</strong>，但是不容易查找到当前节点的双亲，解决方式也很简单，增加一个parent指针指向双亲则可。</p><p>C语言表示的结构体为：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> CSNode{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> CSNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">firstchild, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">nextsibling;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}CSNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://camo.githubusercontent.com/f3050ee54e6a13d45ff3ed62e54df92b63261e822b78428a29d362db5ac827b4/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313837313731363138372d63376464653636612d343264302d343539312d383665652d3464323439396265376533622e706e67" alt="孩子兄弟表示法" tabindex="0" loading="lazy"><figcaption>孩子兄弟表示法</figcaption></figure><h2 id="树、森林和二叉树的相互转换" tabindex="-1"><a class="header-anchor" href="#树、森林和二叉树的相互转换"><span><strong>树、森林和二叉树的相互转换</strong></span></a></h2><p><strong>树转换为二叉树</strong>就是使用上面的<strong>二叉树表示法</strong>则可。需要注意的是根节点没有兄弟故没有右孩子（也就是转换后的二叉树没有右子树）。</p><p>一些画法我觉得没什么用，只要清晰地理解了这个原理便可轻松地画出。</p><p><strong>森林转换为二叉树</strong>和上面的树转换类似，因为森林就是多棵树嘛！那具体怎样转化呢？</p><p>森林中的树的根节点相互视为兄弟节点。将每颗树单独的转换为二叉树，然后从第二颗树开始依次作为前一棵树根节点的右孩子则可。</p><p><strong>二叉树转换为森林</strong>上面的逆运算，将一颗二叉树分离为多颗二叉树，再使用<strong>左孩子右兄弟</strong>的原理得到每颗二叉树对应的树，这些树就构成了最终的森林。</p><p>掌握好基本概念是容易理解和作图的，以下是示意图：</p><figure><img src="https://camo.githubusercontent.com/6698c05fe617d9ed9c5e902023e3bf3ce1ffcba9169ccb34e202dd2f22bc5b01/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323236333736373634302d36313736396463342d323337642d343634372d383062362d3064303436353164666465332e6a706567" alt="三者相互转换示意图" tabindex="0" loading="lazy"><figcaption>三者相互转换示意图</figcaption></figure><h2 id="树和森林的遍历" tabindex="-1"><a class="header-anchor" href="#树和森林的遍历"><span><strong>树和森林的遍历</strong></span></a></h2><p>树的遍历可以分为<strong>先根遍历、后根遍历、层序遍历</strong>，这和二叉树的遍历有所不同，因为树可以有多个孩子，所以无法使用中根遍历。</p><h3 id="先根遍历" tabindex="-1"><a class="header-anchor" href="#先根遍历"><span><strong>先根遍历</strong></span></a></h3><p>若树非空，则先访问根节点，在依次先根遍历根节点的每颗子树。<strong>其遍历序列和这颗树对应二叉树的先序序列相同。</strong></p><h3 id="后根遍历" tabindex="-1"><a class="header-anchor" href="#后根遍历"><span><strong>后根遍历</strong></span></a></h3><p>若树非空，则依次后根遍历根节点的每颗子树。<strong>其遍历序列和这颗树对应二叉树的中序序列相同。</strong> 有时也称后根遍历为中序遍历，这是对于树对应的二叉树而言的。</p><h3 id="层序遍历" tabindex="-1"><a class="header-anchor" href="#层序遍历"><span><strong>层序遍历</strong></span></a></h3><p>若树非空，按层序依次访问每个节点，和二叉树的层序遍历思想类似（使用一个辅助队列）。</p><h2 id="二叉树的定义" tabindex="-1"><a class="header-anchor" href="#二叉树的定义"><span><strong>二叉树的定义</strong></span></a></h2><blockquote><p>定义：是一种特殊的树形结构。</p></blockquote><p>其每个节点至多只有两颗子树，并且二叉树的子树有左右之分，其次序是不能进行交换的。</p><p>因为二叉树也是树的一种，所以在许多地方的性质都是树性质的特殊化。</p><figure><img src="https://camo.githubusercontent.com/5b617deeb57e83f87af2c97aa589e0cfd01a4a6c18b4c5f37dacde2ac15b2dec/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313539303236393738392d32366566663464322d353432642d346232652d623634342d3964336264613330376131352e706e67" alt="二叉树示意图" tabindex="0" loading="lazy"><figcaption>二叉树示意图</figcaption></figure><h2 id="二叉树和有序树的区别" tabindex="-1"><a class="header-anchor" href="#二叉树和有序树的区别"><span><strong>二叉树和有序树的区别</strong></span></a></h2><ul><li><p>度为2的树至少要3个节点，而二叉树可以为空。</p></li><li><p>度为2的有序树的孩子的左右次序是相对的，如果该有序树的孩子节点只有一个则不用分左右，但是二叉树中的节点就算只有一个孩子节点都要区分是左还是右。</p></li></ul><h2 id="几种特殊的二叉树" tabindex="-1"><a class="header-anchor" href="#几种特殊的二叉树"><span><strong>几种特殊的二叉树</strong></span></a></h2><ul><li><strong>满二叉树（FBT）</strong>：一颗高为h的二叉树，节点数有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{n} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，则称其为满二叉树，将树装“满”了。</li></ul><figure><img src="https://camo.githubusercontent.com/9a0bba2fbe2e2ac6f2be40efe5b3597cb9a866902d332c41dd9de7f6b906f3be/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313631333632333833382d63333566616635372d666663382d343535342d613736382d3030396338663664643834372e706e67" alt="满二叉树示意图" tabindex="0" loading="lazy"><figcaption>满二叉树示意图</figcaption></figure><ul><li><strong>完全二叉树（CBT）</strong>：高度为h、有n个节点的二叉树，并且每个节点都与高度为h的满二叉树中编号一一对应时，称其为完全二叉树。也就是说完全二叉树是满二叉树在叶子节点那一层减少一些右侧连续的节点。</li></ul><figure><img src="https://camo.githubusercontent.com/2031900f42335021fd166b432fb27d89940d1b938216701fd48e8e48b00cd230/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313631333534363733372d65633539353839372d323439632d346435362d613264612d6134383335343561333263622e706e67" alt="完全二叉树示意图" tabindex="0" loading="lazy"><figcaption>完全二叉树示意图</figcaption></figure><ul><li><strong>二叉排序树（BST）</strong>：左子树上的所有节点全部都小于根节点的值；右子树的所有节点全部都大于根节点的值；左右子树又分别为一颗二叉排序树。</li></ul><figure><img src="https://camo.githubusercontent.com/ecfc61d5e0efb006a3e33019a1168083b083da7b414a619da376ee1ae9a83bf8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313636323336393730362d30383562653930362d373361622d346566342d616265372d3838643633363563626461352e706e67" alt="二叉排序树示意图" tabindex="0" loading="lazy"><figcaption>二叉排序树示意图</figcaption></figure><ul><li><strong>平衡二叉树（AVL）</strong>：树中的任意一个节点的左子树和右子树的高度只差的绝对值不超过1。</li></ul><figure><img src="https://camo.githubusercontent.com/9e859e65b4f81ea4fec07dc57e7abda83658b2015b07c0eddeed0a0cd2e0fcff/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313636323630333038312d61353831363562612d643535372d346165622d393137632d6237313563623534636463642e706e67" alt="平衡二叉树示意图" tabindex="0" loading="lazy"><figcaption>平衡二叉树示意图</figcaption></figure><ul><li><strong>正则二叉树（RBT）</strong>：树中的每个分支节点都有两个节点，也就是说树中节点的度只有0和2两种。</li></ul><figure><img src="https://camo.githubusercontent.com/b4332f67d3c5c99e2400d865ce58c899a3ce384ec7c15fbbe9f9f799546d1bf7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313636323737303933332d61643261363538332d663564382d343039662d626339322d3837336531653266323438332e706e67" alt="正则二叉树示意图" tabindex="0" loading="lazy"><figcaption>正则二叉树示意图</figcaption></figure><h2 id="二叉树的性质" tabindex="-1"><a class="header-anchor" href="#二叉树的性质"><span><strong>二叉树的性质</strong></span></a></h2><p>二叉树的性质就是树性质一种特殊化。</p><ul><li><p>非空二叉树上的叶节点数等于度为2的节点数加1，即 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0 = n_2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong>。</p></li><li><p>非空二叉树的第k层最多有 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong> 个节点。</p></li><li><p>高度为h的二叉树最多有 <strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></strong> 个节点。</p></li><li><p>将完全二叉树按从上到下，从左至右的顺序依次编号1,2,3,4...,n。则有以下特性：</p></li></ul><ol><li><p>最后一个分支节点编号为[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>]，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≤</mo><mo stretchy="false">[</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \leq [\frac {n}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span>则为分支节点，否则为叶子节点。</p></li><li><p>叶子节点只可以出现在最底层或者倒数第二层。</p></li><li><p>若有度为1的节点，该类节点只能有一个，并且该节点只能是左孩子。</p></li><li><p>编号之后，若出现编号i的节点为叶子节点或只有左孩子，则编号大于i的节点均为叶子节点。</p></li><li><p>若n为奇数，则每个分支节点都有左、右孩子；若n为偶数，则编号最大的分支节点（i=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>）只有左孩子，其余分支节点都有左、右孩子。</p></li><li><p>当i&gt;1时，节点i的双亲节点编号为[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>]。</p></li><li><p>若节点i有左、右孩子，则左孩子编号为2i，右孩子编号为2i + 1。</p></li><li><p>节点i所在层次为[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>i</mi></mrow><annotation encoding="application/x-tex">log_2i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">i</span></span></span></span>] + 1。</p></li></ol><ul><li>具有n（n &gt; 0）个节点的完全二叉树的高度为[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_2(n + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>]（向上取整）或[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>] + 1。</li></ul><h2 id="二叉树的存储结构" tabindex="-1"><a class="header-anchor" href="#二叉树的存储结构"><span><strong>二叉树的存储结构</strong></span></a></h2><h3 id="顺序存储结构" tabindex="-1"><a class="header-anchor" href="#顺序存储结构"><span><strong>顺序存储结构</strong></span></a></h3><p>可以将完全二叉树从左到右每个节点进行编号。但是这里有个问题，对于完全二叉树和满二叉树可以将每个存储单元利用起来，如果是普通的二叉树，则要注意在某些没有节点的位置上补0，这样是很浪费存储空间的。</p><figure><img src="https://camo.githubusercontent.com/47399eeb184c2238ca28be1beb038e609a6fe1aa1b476a2ec348626ead45be2b/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734313736313631373339372d33336466376337362d396138362d346661382d396333332d6564626664336563316165382e6a7065673f782d6f73732d70726f636573733d696d6167652f6175746f2d6f7269656e742c31" alt="顺序存储示意图" tabindex="0" loading="lazy"><figcaption>顺序存储示意图</figcaption></figure><h3 id="链式存储结构" tabindex="-1"><a class="header-anchor" href="#链式存储结构"><span><strong>链式存储结构</strong></span></a></h3><p>二叉树一般都采用链式存储结构，使用链表节点来存储二叉树中的每一个节点。一个节点包括 <strong>左指针域、值、右指针域</strong>。</p><p>使用C语言表示的结构体为：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TreeNode{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TreeNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lchild;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TreeNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">rchild;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}TreeNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://camo.githubusercontent.com/45cc0853b453b95b82f7901f1e394ba59c1caca072d77bc70fdcb1dcaed1c314/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313736323236353433352d37613632376233632d626664342d346263612d616661322d3439646337353639326262302e706e67" alt="链式存储示意图" tabindex="0" loading="lazy"><figcaption>链式存储示意图</figcaption></figure><p>其中的左右指针分别指向孩子节点地址；我们可以看到二叉树有n个节点的话，则会有2n个域，其中只有n - 1个域用于指向孩子节点，会有n + 1个空域。而这个空域在后面就是用于存放 <strong>“线索”</strong> 的。</p><h2 id="二叉树的遍历和线索二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历和线索二叉树"><span><strong>二叉树的遍历和线索二叉树</strong></span></a></h2><h3 id="二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历"><span><strong>二叉树的遍历</strong></span></a></h3><blockquote><p>定义：按某条搜索路径访问树中每个节点，使得每个节点有且仅被访问一次。</p></blockquote><p>由二叉树的递归定义，我们可以知道通过递归的手段对二叉树遍历是非常容易的。</p><p>进行递归遍历时，就有不同的选择了，<strong>我们以根被访问的次序可以将递归遍历分为：NLR、LNR、LRM。（分别为先序遍历、中序遍历、后序遍历）</strong></p><h3 id="四种遍历方式" tabindex="-1"><a class="header-anchor" href="#四种遍历方式"><span><strong>四种遍历方式</strong></span></a></h3><p><strong>先序遍历</strong><br> 判断二叉树是否为空，为空什么都不做，否则：</p><ol><li>访问根节点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><p>C语言代码实现：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> preOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">TreeNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(root </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    preOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    preOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>中序遍历</strong><br> 判断二叉树是否为空，为空什么都不做，否则：</p><ol><li>中序遍历左子树</li><li>访问根节点</li><li>中序遍历右子树</li></ol><p>C语言代码实现：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> inOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">TreeNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(root </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    inOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    inOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>后序遍历</strong><br> 判断二叉树是否为空，为空什么都不做，否则：</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点</li></ol><p>C语言代码实现：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> postOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">TreeNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(root </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    postOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    postOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了递归遍历外，还有<strong>层序遍历</strong>，一层一层的遍历，也就是之前在队列应用那说的方法。忘记了可以点击 <a href="https://amatureemoprince.github.io/TechnologyAndLife/cs-basic/data-structure/stack-queue-array.html#%E9%98%9F%E5%88%97%E5%9C%A8%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" target="_blank" rel="noopener noreferrer">队列在层序遍历中的应用</a> 进行复习。</p><p>C语言代码实现：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> levelOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">TreeNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Queue </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">queue </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> initQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    TreeNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">node;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //将根节点入队</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    inQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(queue, root);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //核心操作</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    whille</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(queue)){</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        deQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(queue, node);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            inQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(queue, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            inQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(queue, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="遍历构造二叉树" tabindex="-1"><a class="header-anchor" href="#遍历构造二叉树"><span><strong>遍历构造二叉树</strong></span></a></h3><p><strong>如果给出一个中序序列和任意一个其他序列则可以得出唯一的二叉树结构。但是如果两个序列中没有中序序列就不能确定唯一结构了。</strong></p><p>思路都是类似的，举个例子：前序序列为：ABDECF，中序序列为：DBEACF</p><p>我们可以进行分析：</p><p>前序序列是以A开头的，说明二叉树的根节点为A，然后在中序序列中可以得到左子树有DBE，右子树有CF。</p><p>然后分析左子树，在前序序列中B在前则说明其作为子树的根，再根据中序序列知道D、E分别为左右孩子节点。</p><p>最后分析右子树，在前序序列中C在前显然为子树的根，根据中序序列可知F为右孩子。故可得最后的二叉树结构：</p><pre><code>         A 
        / \
       B   C
      / \   \
     D   E   F 
</code></pre><p>带有中序序列和其他任意序列的分析都如上。<strong>需要注意的是在不带中序序列的任意两个序列的分析。</strong></p><h2 id="线索二叉树" tabindex="-1"><a class="header-anchor" href="#线索二叉树"><span><strong>线索二叉树</strong></span></a></h2><p>采用一种序列方式遍历二叉树可以得到一种遍历序列，该序列是一种线性序列，故可以使得除第一个和最后一个节点外都有一个直接前驱和直接后继节点。</p><p>但是传统的二叉链表只能表示父子关系，而不能表示前驱和后继关系。<strong>为了实现这个目的，可以将二叉树中的还剩余的n + 1个空链域利用起来。这样就可以像遍历单链表那样遍历二叉树了，引入线索二叉树的目的也是为了加快查找节点前驱和后继节点的速度。</strong></p><p>因为二叉树节点中的左右指针是不确定指向孩子节点还是前驱、后继，所以要增加两个标志位（ltag、rtag），用以表示指向的具体是什么！</p><p>使用C语言表示的节点结构体为：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lchild, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">rchild;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ltag, rtag;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}ThreadNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container important"><p class="hint-container-title">规定</p><p>若节点<strong>无左子树</strong>，则<strong>lchild</strong>指向该节点的<strong>前驱节点</strong>，<strong>ltag为1</strong>，<strong>否则</strong>lchild指向该节点的左孩子节点，ltag为0；</p><p>若节点<strong>无右子树</strong>，则<strong>rchild</strong>指向该节点的<strong>后继节点</strong>，<strong>rtag为1</strong>，<strong>否则</strong>rchild指向该节点的右孩子节点，rtag为0；</p></div><h2 id="线索化" tabindex="-1"><a class="header-anchor" href="#线索化"><span><strong>线索化</strong></span></a></h2><p>二叉树的 <strong>线索化</strong> 是将二叉链表中的空指针改为指向前驱或者后继的线索（地址）。但是前驱或后继的信息只有在遍历时才能得到，故 <strong>线索化</strong> 的实质就是遍历一次二叉树。</p><p>以中序线索二叉树的建立举例：</p><p>因为我们要在遍历的过程中将节点的空链域指向前驱和后继，所以需要两个指针 pre、p，分别是指向刚刚访问过的节点和正在访问的节点。在这里pre为p的前驱，p为pre的后继。</p><p>那么在遍历的过程中，<strong>要检查p的左指针是否为空，为空则指向pre（不为空就不用管了，因为是有孩子节点的）；要检查pre的右指针是否为空，为空则指向p。</strong></p><figure><img src="https://camo.githubusercontent.com/9e2c7fc752814d006de2644ee72b27e6dde8393797a406e51f966d68a7a0f576/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734313932323339313138352d31323739663762322d323963342d346339382d383336642d6638613266306330316532342e6a706567" alt="中序线索二叉树及二叉链表示" tabindex="0" loading="lazy"><figcaption>中序线索二叉树及二叉链表示</figcaption></figure><h3 id="中序线索化二叉树" tabindex="-1"><a class="header-anchor" href="#中序线索化二叉树"><span><strong>中序线索化二叉树</strong></span></a></h3><p>这样遍历一遍后就完成了线索化了。下面是具体的C语言代码：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> inThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">**</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">pre</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (p </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 递归线索化左子树</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        inThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(pre, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 处理当前节点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果左孩子为空，设置前驱线索</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ltag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果前驱的右孩子为空，设置后继线索</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rtag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 更新前驱节点为当前节点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 递归线索化右子树</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        inThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(pre, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createThreadTree</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">**</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">root</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(root </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        inThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre, root);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        pre</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        pre</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rtag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="先序线索化二叉树" tabindex="-1"><a class="header-anchor" href="#先序线索化二叉树"><span><strong>先序线索化二叉树</strong></span></a></h3><p>先序线索化二叉树C语言表示：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> preThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">**</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">pre</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (p </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 处理当前节点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果左孩子为空，设置前驱线索</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ltag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果前驱的右孩子为空，设置后继线索</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rtag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 更新前驱节点为当前节点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 递归线索化左子树</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ltag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果左孩子是普通孩子，递归线索化左子树</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            preThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(pre, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 递归线索化右子树</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rtag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果右孩子是普通孩子，递归线索化右子树</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            preThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(pre, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="后序线索化二叉树" tabindex="-1"><a class="header-anchor" href="#后序线索化二叉树"><span><strong>后序线索化二叉树</strong></span></a></h3><p>后序线索化化二叉树C语言表示：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> postThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">**</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">pre</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ThreadNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (p </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 递归线索化左子树</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        postThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(pre, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 递归线索化右子树</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        postThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(pre, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 处理当前节点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果左孩子为空，设置前驱线索</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">lchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ltag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果前驱的右孩子为空，设置后继线索</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rchild</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre)-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">rtag</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 更新前驱节点为当前节点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">pre </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> p;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样做并不是很方便，为了更加地方便我们可以砸二叉树的线索链表上添加一个<strong>头结点</strong>，让其lchild指针指向二叉树的根节点，让其rchild指针指向中序遍历时访问的最后有一个节点并让中序遍历的第一个节点lchild指向头节点，最后一个节点的rchild指向头结点。</p><p>这就像在二叉树上建立了一个双向线索链表，可以方便地从前往后和从后往前对线索二叉树进行遍历。</p><h2 id="树和二叉树的应用" tabindex="-1"><a class="header-anchor" href="#树和二叉树的应用"><span><strong>树和二叉树的应用</strong></span></a></h2><h3 id="哈夫曼树" tabindex="-1"><a class="header-anchor" href="#哈夫曼树"><span><strong>哈夫曼树</strong></span></a></h3><blockquote><p>定义：含有n个带权叶节点的二叉树中，其带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称为最优二叉树。</p></blockquote><p>这里需要说明一下什么叫WPL：<strong>对于节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 而言，该节点的WPL是根节点到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的长度乘以该节点的权值。对于二叉树而言，该树的WPL为所有叶子结点的WPL之和。</strong></p><figure><img src="https://camo.githubusercontent.com/8075e301cdfe4ba6eff98d01a0fef39261fb76a494a0df2829ca4b9f22b45403/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323238343536383330382d36653130396262612d376439662d346561632d613938642d3239303830373261396630342e6a706567" alt="有不同带权长度的二叉树" tabindex="0" loading="lazy"><figcaption>有不同带权长度的二叉树</figcaption></figure><p>分别计算一下这三颗二叉树的<strong>带权路径长度</strong>：</p><p>a：WPL = (7 + 5 + 2 + 4) x 2 = 36</p><p>b：WPL = (7 + 5) x 3 + 4 x 2 + 2 x 1 = 46</p><p>c：WPL = 7 x 1 + 5 x 2 + (2 + 4) x 3 = 35</p><p>可以看出这三颗二叉树的顶点集和边集都是一样的，但是其带权路径长度不同。我们要学习的重点就是<strong>怎样找到最小带权路径对应的二叉树！</strong></p><p>哈夫曼树的构造方法：</p><p>存在n个权值分别为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">w_1, w_2, w_3, ..., w_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的节点，构造步骤如下：</p><ol><li><p>将n个节点分别作为一颗二叉树的根节点，构成一个森林W。</p></li><li><p>构造一个新的节点N，从W中选择两个权值最小的节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">w_i, w_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，将N的权值设置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><msub><mi>w</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">w_i + w_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，并将最小的两个节点作为N的左右孩子。</p></li><li><p>将W中选出来的两个节点删除并将新的二叉树N加入到W中。</p></li><li><p>重复2、3直到F中只剩下一棵二叉树为止。</p></li></ol><p>让我们来看看<strong>哈夫曼树存在一些什么性质</strong>：</p><ul><li><p>每颗初始在W中的节点都会称为叶子结点，且权值越小离根节点的路径长度就越大。</p></li><li><p>构造过程中会构造n - 1个新节点，所以哈夫曼树共有2n - 1个节点。</p></li><li><p>度为m的哈夫曼树中只会存在度为0和m的节点。（通常情况下哈夫曼树度为2，但不排除其他情况）</p></li></ul><h3 id="哈夫曼编码" tabindex="-1"><a class="header-anchor" href="#哈夫曼编码"><span><strong>哈夫曼编码</strong></span></a></h3><p>在学习这个知识之前需要知道什么是<strong>固定长度编码</strong>、<strong>可变长度编码</strong>、<strong>前缀编码</strong>。</p><blockquote><p>固定长度编码：对每个字符用相等长度的二进制位表示。<br> 可变长编码：允许对不同字符用不同长度的二进制位表示。<br> 前缀编码：没有一个编码是另一个编码的前缀。</p></blockquote><p>显然的，采用可变长编码可以起到压缩数据的效果。我们将常用字符用位数少的二进制表示，不常用字符用位数多的二进制表示，这样可以将字符的平均编码长度减短。</p><p><strong>使用哈夫曼编码是可以有效地进行数据压缩的</strong>。原理是使用哈夫曼树，每个节点中的<strong>权值含义</strong>为<strong>表示的字符出现频度</strong>。</p><p>可以举个例子：下面的中括号中的值为对应字符出现的次数。</p><figure><img src="https://camo.githubusercontent.com/ed0bb9478e2cddf52c665d796f0c3b71023f09093941c0db2887fa1cf7a5098b/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323238373035373832332d64626664623932342d626234362d343261352d386639332d3232356665343235313162302e6a706567" alt="使用哈夫曼树进行哈夫曼编码" tabindex="0" loading="lazy"><figcaption>使用哈夫曼树进行哈夫曼编码</figcaption></figure><p>我们可以知道其WPL = 1 x 45 + 3 x (13 + 12 + 16) + 4 x (5 + 9) = 224</p><p>但如果我们采用定长编码的话，就需要300位进制了。因为要表示此6种字符需要3位二进制，一共所有字符出现了100次，所以对应的三叉树WPL = 3 x 100 = 300。</p><p>此时哈夫曼编码压缩近25%的数据。<strong>使用哈夫曼编码可以设计出总长度最短的二进制前缀编码。</strong></p><div class="hint-container tip"><p class="hint-container-title">小贴士</p><p>因为没有规定节点的左右，所以构造出来的哈夫曼树不唯一，但是不管是什么哈夫曼树，其WPL都是相同且最小的。</p></div><h3 id="并查集" tabindex="-1"><a class="header-anchor" href="#并查集"><span><strong>并查集</strong></span></a></h3><blockquote><p>定义：是一种简单的集合表示。</p></blockquote></div><!----><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><span class="vp-meta-info" data-allow-mismatch="text">2025/3/26 00:41:32</span></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 2069057986@qq.com">lj</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/cs-basic/data-structure/string.html" aria-label="串" iconsizing="both"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><i class="vp-icon fas fa-paper-plane" sizing="height"></i>串</div></a><a class="route-link auto-link next" href="/cs-basic/data-structure/graph.html" aria-label="图" iconsizing="both"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">图<i class="vp-icon fas fa-image" sizing="height"></i></div></a></nav><!----><!----><!--]--></main><!--]--><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">茶与代码，诗与远方 | 一个程序员的技术与生活随想</div><div class="vp-copyright">Copyright © 2025 阿杰 like coding bug ❥ </div></footer></div><!--]--><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script src="/assets/js/runtime~app.ec5fa5f3.js" defer></script><script src="/assets/js/1935.4522daaa.js" defer></script><script src="/assets/js/app.11fa9fe8.js" defer></script>
  </body>
</html>
