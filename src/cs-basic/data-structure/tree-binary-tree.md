---
title: 树
categories:
  - "408"
  - "数据结构"
  - "树"
icon: tree
---
## **树**
### **树的定义**
> 定义：是n($n \geq 0$)个节点的**有限集**。当n = 0时，称为空树。在任意一颗非空树中应满足：
> 1. 有且仅有一个特定的称为**根**的结点。
> 2. 当n > 1时，其余节点可分为m(m > 0)个互不相交的树，并称其为**子树**。

根据上面树的定义可以知道：树是递归的，树中有包含树；**树是一种逻辑结构和分层结构**。

并且树的根节点是没有前驱的，除根节点外，其余所有节点有且仅有一个前驱（双亲），但是树中的每个节点可以有0个或多个后继（孩子）。

![树的示意图](https://camo.githubusercontent.com/10c7c080594f09e22acc36e1b73f9bba2fd8727014cccdea357a41a33f64a7b3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313532383537323234332d63343865656666632d373732352d343837612d613531392d3831303665393566373535622e706e67)
### **基本术语**
我们需要知道关于树的一些专业术语。
- 祖先：使用D节点举例，A到D的唯一路径上除了D的所有的节点全为D的祖先节点。
- 子孙：一个节点下的所有子树上的节点都为其子孙，如：D、E、F为C的子孙。
- 双亲：根节点到该节点路径上离该节点最近的节点，如：C就为D的双亲，也为E、F的双亲。
- 孩子：和双亲类似，D、E、F都为C的孩子，只有根节点没有双亲。
- 兄弟：有相同双亲的节点称为兄弟节点。
- 堂兄弟：双亲在同一层的结点称为堂兄弟，如：C、G、I为堂兄弟。
- 节点的层次：如上面的图，根节点在第一层，往下层数依次增加。
- 节点的深度：就是节点的层次。
- 树的高度（深度）：树中节点的最大层数。
- 节点的高度：是以该节点为根节点的子树高度。
- 节点的度：有几个孩子节点，度就为多少。
- 树的度：树中节点的最大的度为树的度。
- 分支节点：度大于0的节点。
- 叶节点：度为0的节点。
- 有序树：树中节点的各子树从做到右是有次序的，不能互换。
- 无序树：就和上面相反呗，无序并可以相互交换（仅在有一个以上孩子节点时成立）。
- 路径：树中两个节点之间的路径是由这两个节点之间所经过的节点序列组成的。
- 路径长度：是整个路径上边的条数。

### **森林**
> 定义：是m($m \geq 0$)颗互不相交的树的集合。

树和森林在现实生活中是包含关系。在数据结构中也很类似，给m颗树形成的森林加上一个节点，并把这m颗树作为该节点的子树，则森林就变为了树；而树去掉根节点又可以变为森林。
### **树的性质**
在树中最重要的就是节点、度数、高度之间的关系了，所以我们来学习这些性质。

**1. 树的节点数n等于所有节点的度数之和加一**：所有的度数之和就是除了根节点之外所有节点之和，所以在此基础上加一就可以得到树的节点数n了。

**2. 度为m的树中第i层上之多有$m^{i - 1}$个节点(i $\geq 1$)**：因为条件是之多，故只要每个节点的度都为m，这样在在第i层的结点数就最多。

**3. 高度为h的m叉树至多有$\frac{m^h - 1}{m - 1}$个节点**：根据等比数列的前n项和公式可以轻松得到这个结论。

**4. 度为m、具有n个节点的树的最小高度h为$[log_m(n(m - 1)) + 1]$(注意是需要向下取整的)**：因为要求是最小的高度，所以在最后一层之上的每个节点的度都要为m，设树的高度为h，前h - 1层最多有 **$\frac{m^{h - 1}}{m - 1}$** 个节点，前n层最多有 **$\frac{m^h}{m - 1}$** 个节点，并且要满足 **$\frac{m^{h - 1}}{m - 1} < n \leq  \frac{m^h}{m - 1}$**，根据这个不等式可得最终结果。

**5. 度为m、具有n个节点的树的最大高度h为$n - m + 1$**：条件为h最高，则满足在上部分为两两节点连接，只在两两节点相连的最后一个节点实现度为m。
### **树的存储结构**

### **树和森林的相互转换**

### **树和森林的遍历**
![二叉树示意图](https://camo.githubusercontent.com/5b617deeb57e83f87af2c97aa589e0cfd01a4a6c18b4c5f37dacde2ac15b2dec/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313539303236393738392d32366566663464322d353432642d346232652d623634342d3964336264613330376131352e706e67)
## **二叉树**
### **二叉树的定义**
> 定义：是一种特殊的树形结构。

其每个节点至多只有两颗子树，并且二叉树的子树有左右之分，其次序是不能进行交换的。

因为二叉树也是树的一种，所以在许多地方的性质都是树性质的特殊化。

### **二叉树和有序树的区别**
- 度为2的树至少要3个节点，而二叉树可以为空。

- 度为2的有序树的孩子的左右次序是相对的，如果该有序树的孩子节点只有一个则不用分左右，但是二叉树中的节点就算只有一个孩子节点都要区分是左还是右。
### **几种特殊的二叉树**
- **满二叉树**：一颗高为h的二叉树，节点数有$2^{n} - 1$，则称其为满二叉树，将树装“满”了。

![满二叉树示意图](https://camo.githubusercontent.com/9a0bba2fbe2e2ac6f2be40efe5b3597cb9a866902d332c41dd9de7f6b906f3be/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313631333632333833382d63333566616635372d666663382d343535342d613736382d3030396338663664643834372e706e67)
- 完全二叉树：高度为h、有n个节点的二叉树，并且每个节点都与高度为h的满二叉树中编号一一对应时，称其为完全二叉树。也就是说完全二叉树是满二叉树在叶子节点那一层减少一些右侧连续的节点。

![完全二叉树示意图](https://camo.githubusercontent.com/2031900f42335021fd166b432fb27d89940d1b938216701fd48e8e48b00cd230/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313631333534363733372d65633539353839372d323439632d346435362d613264612d6134383335343561333263622e706e67)
- **二叉排序树**：左子树上的所有节点全部都小于根节点的值；右子树的所有节点全部都大于根节点的值；左右子树又分别为一颗二叉排序树。

![二叉排序树示意图](https://camo.githubusercontent.com/ecfc61d5e0efb006a3e33019a1168083b083da7b414a619da376ee1ae9a83bf8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313636323336393730362d30383562653930362d373361622d346566342d616265372d3838643633363563626461352e706e67)
- **平衡二叉树（AVL）**：树中的任意一个节点的左子树和右子树的高度只差的绝对值不超过1。

![平衡二叉树示意图](https://camo.githubusercontent.com/9e859e65b4f81ea4fec07dc57e7abda83658b2015b07c0eddeed0a0cd2e0fcff/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313636323630333038312d61353831363562612d643535372d346165622d393137632d6237313563623534636463642e706e67)
- **正则二叉树**：树中的每个分支节点都有两个节点，也就是说树中节点的度只有0和2两种。

![正则二叉树示意图](https://camo.githubusercontent.com/b4332f67d3c5c99e2400d865ce58c899a3ce384ec7c15fbbe9f9f799546d1bf7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313636323737303933332d61643261363538332d663564382d343039662d626339322d3837336531653266323438332e706e67)
### **二叉树的性质**
二叉树的性质就是树性质一种特殊化。

- 非空二叉树上的叶节点数等于度为2的节点数加1，即 **$n_0 = n_2 + 1$**。

- 非空二叉树的第k层最多有 **$2^k - 1$** 个节点。 

- 高度为h的二叉树最多有 **$2^h - 1$** 个节点。

- 将完全二叉树按从上到下，从左至右的顺序依次编号1,2,3,4...,n。则有以下特性：
1. 最后一个分支节点编号为[$\frac {n}{2}$]，若$i \leq [\frac {n}{2}]$则为分支节点，否则为叶子节点。

2. 叶子节点只可以出现在最底层或者倒数第二层。

3. 若有度为1的节点，该类节点只能有一个，并且该节点只能是左孩子。

4. 编号之后，若出现编号i的节点为叶子节点或只有左孩子，则编号大于i的节点均为叶子节点。

5. 若n为奇数，则每个分支节点都有左、右孩子；若n为偶数，则编号最大的分支节点（i=$\frac {n}{2}$）只有左孩子，其余分支节点都有左、右孩子。

6. 当i>1时，节点i的双亲节点编号为[$\frac {n}{2}$]。

7. 若节点i有左、右孩子，则左孩子编号为2i，右孩子编号为2i + 1。

8. 节点i所在层次为[$log_2i$] + 1。

- 具有n（n > 0）个节点的完全二叉树的高度为[$log_2(n + 1)$]或[$log_2(n)$] + 1。
### **二叉树的存储结构**
#### **顺序存储结构**
可以将完全二叉树从左到右每个节点进行编号。但是这里有个问题，对于完全二叉树和满二叉树可以将每个存储单元利用起来，如果是普通的二叉树，则要注意在某些没有节点的位置上补0，这样是很浪费存储空间的。

![顺序存储示意图](https://camo.githubusercontent.com/47399eeb184c2238ca28be1beb038e609a6fe1aa1b476a2ec348626ead45be2b/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734313736313631373339372d33336466376337362d396138362d346661382d396333332d6564626664336563316165382e6a7065673f782d6f73732d70726f636573733d696d6167652f6175746f2d6f7269656e742c31)
#### **链式存储结构**
二叉树一般都采用链式存储结构，使用链表节点来存储二叉树中的每一个节点。一个节点包括 **左指针域、值、右指针域**。

使用C语言表示的结构体为：
```c
typedef struct TreeNode{
    struct TreeNode *lchild;
    int data;
    struct TreeNode *rchild;
}TreeNode;
```

![链式存储示意图](https://camo.githubusercontent.com/45cc0853b453b95b82f7901f1e394ba59c1caca072d77bc70fdcb1dcaed1c314/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313736323236353433352d37613632376233632d626664342d346263612d616661322d3439646337353639326262302e706e67)

其中的左右指针分别指向孩子节点地址；我们可以看到二叉树有n个节点的话，则会有2n个域，其中只有n - 1个域用于指向孩子节点，会有n + 1个空域。而这个空域在后面就是用于存放 **“线索”** 的。
## **二叉树的遍历和线索二叉树**
### **二叉树的遍历**
> 定义：按某条搜索路径访问树中每个节点，使得每个节点有且仅被访问一次。

由二叉树的递归定义，我们可以知道通过递归的手段对二叉树遍历是非常容易的。

进行递归遍历时，就有不同的选择了，**我们以根被访问的次序可以将递归遍历分为：NLR、LNR、LRM。（分别为先序遍历、中序遍历、后序遍历）**

**先序遍历**
判断二叉树是否为空，为空什么都不做，否则：
1. 访问根节点
2. 先序遍历左子树
3. 先序遍历右子树

C语言代码实现：
```c
void preOrder(TreeNode *root){
    if(root == NULL){
        return ;
    }
    printf("%d ", root->data);
    preOrder(root->lchild);
    preOrder(root->rchild);
}
```
**中序遍历**
判断二叉树是否为空，为空什么都不做，否则：
1. 中序遍历左子树
2. 访问根节点
3. 中序遍历右子树

C语言代码实现：
```c
void inOrder(TreeNode *root){
    if(root == NULL){
        return ;
    }
    inOrder(root->lchild);
    printf("%d ", root->data);
    inOrder(root->rchild);
}
```
**后序遍历**
判断二叉树是否为空，为空什么都不做，否则：
1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根节点

C语言代码实现：
```c
void postOrder(TreeNode *root){
    if(root == NULL){
        return ;
    }
    postOrder(root->lchild);
    postOrder(root->rchild);
    printf("%d ", root->data);
}
```

除了递归遍历外，还有**层序遍历**，一层一层的遍历，也就是之前在队列应用那说的方法。忘记了可以点击 [队列在层序遍历中的应用](https://amatureemoprince.github.io/TechnologyAndLife/cs-basic/data-structure/stack-queue-array.html#%E9%98%9F%E5%88%97%E5%9C%A8%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8) 进行复习。

C语言代码实现：
```c
void levelOrder(TreeNode *root){
    Queue initQueue();
}
```
### **线索二叉树**

## **树和二叉树的应用**
