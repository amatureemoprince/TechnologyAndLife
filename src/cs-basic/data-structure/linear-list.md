---
title: 线性表
icon: water
categories:
  - "408"
  - "数据结构"
  - "线性结构"
---
## 线性表的定义
> 线性表是具有**相同数据类型**的n（n >= 0）个数据元素的**有限序列**，其中n为表长，当n = 0时线性表是一个空表。若使用L命名线性表，则表示为：
> **L = (a1, a2, ..., an)**
 
重要的是有限个且类型相同。我们可以知道线性表有一下的特性：
- 元素类型相同。
- 个数有限。
- 除了第一个元素，其余每个元素都有一个直接前驱。
- 除了最后一个元素，其余每个元素都有一个直接后继。

线性表只是一种**逻辑结构**，表示的是元素之间是“挨着”的关系，它有不同的物理实现方式（顺序表、链表）。

## 基本操作
一般来说，学习了一个数据结构的结构后，就需要学习在这个结构上我们可以进行的操作。在这里学习的线性表具有的操作有：
- 初始化：InitList()
- 求表长：Length()
- 按位插入：ListInsert(Element *head, int val, int location)
等等
这些操作知道就可以了，考试出题是让我们进行实现的，不是让我们默写的。

## 顺序表
在上面我们进行了定义线性表，我们知道其是一种逻辑结构，具体的实现有两种。

这里的顺序表就是其中一种。**顺序表是采用顺序存储的，也就是分配了一块连续的物理地址用于存储线性表中的数据元素。使其不仅在逻辑上连续，在物理层面上仍然连续。**

由此我们可以看出，如果知道一个顺序表的起始地址和要找的次序，我们可以直接找出该次序上的元素。这就是C语言中的数组呀！

如：一个数组arr = [12, 34, 13, 43]，我们要求这个数组上第2个元素，可以直接`printf("%d", arr[1]);`。
:::tip 有点不对劲
上面求的不是第二个元素吗？为什么使用的是`printf("%d", arr[1]);`呀？

这里就需要说明一下：数组上元素对应的位置称为索引，而索引是从0开始的，故求的是第二个元素，采用的却是`printf("%d", arr[1]);`。
:::

### 顺序表的优点和缺点
我们为什么会采用顺序表实现线性表呢？肯定是需要它给我们带来的优势撒！那么它有什么优势呢？如下：
 - 随机访问：一个数组，无论我们想访问第1个元素还是10000个元素，访问的时间复杂度都是O(1)。
 - 存储密度高：除了要存储的数据没有其他的无用信息。
**除了优点，还有以下缺点：**
 - 插入、删除需要移动大量元素：在一个具有n个元素的数组中删除第一个元素需要将后面的n - 1个元素都向前移动，十分的不方便。平均也要移动$\frac{n}{2}个元素$
 - 分配不方便：因为需要一段连续的地址，如果计算机中没有的话，就不会进行分配，非常难受。

## 链表
这是线性表的另一种实现方式，采用一个一个的节点表示并通过指针连接。

**节点的表示为：
+-------+------+
| data  | next |
+-------+------+**
使用C语言表示的结构体为（类型指明为具体的int）：
```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;
```
next为指向下一个Node的指针，通过这个指针就可以找到与其紧挨着的元素了。就像一群人，两两之间使用一条绳子进行联系，这里的指针也起到相同的作用。

使用链表的好处在哪里呢？显而易见这个和顺序表是互补的。
- 便于插入和删除：想要插入一个node的话，我们直接改变next的指向就行了，不用再移动大量的元素。
- 不再需要连续的地址块：此时的联系不是通过物理上的“挨着”实现的，而是采用“绳子”的形式。
**那缺点呢？**
- 不再能随机存储：因为我们是不知道每个node的详细地址的，所以只能通过next去找寻。
- 存储密度低：一个node除了要存储data之外还要额外存储一个next。

## 顺序表和链表之间的差别
根据上面顺序表和链表的意义可以知道：
链表更加灵活不需要分配一段连续的地址块并且在插入和删除时很方便但也会导致访问元素很困难（只能一次一次的遍历）；顺序表因为是连续的所以可以轻松的访问任意一个元素但这也导致灵活度的缺失。

所以在一些插入、删除行为非常频繁的场景下可以使用链表，而在访问元素次数多的场景下可以使用顺序表！

## 额外的补充
在真实的场景中链表真的常用吗？我们可以思考一个问题，如果一个数组在移动大量的元素的情况下使用的时间比链表修改指针的时间更少的话，我们为什么要使用链表呢？

因为数组的每个元素我们都要随机访问，所以在插入时可以直接开始移动元素。而链表想要插入元素首先得遍历到要插入位置的前一个节点。在这里的操作中，遍历需花费的时间是占大头的，反而多次的修改所需的时间是更少的。

就连Java中创造LinkList的作者都明确地说了“他自己从不使用LinkList”。

![图片为证](https://camo.githubusercontent.com/fbc58d844d97136609b9d64c7cf809a0761e57a4516b3274e457148096c8475b/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313136313131323435372d61623439363739622d306538342d343237302d626239612d3532633736663566636534662e706e67)

ok，我们来做一个实验：
分别使用一个数组和一个链表随机插入10000个元素，看看那个使用的时间更久。
```java
package com.lj.blog.main;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

/**
 * @ClassName ArrayMain
 * @Description
 * @Author Dark Chocolate 2069057986@qq.com
 * @Date 2025/3/5 16:09
 * @Version JDK 17
 */
public class ArrayMain {

        private static final int COUNT = 10000;

        static List<Integer> fillList(List<Integer> list) {
            for (int i = 0; i < COUNT; i++) {
                list.add(i);
            }
            return list;
        }

        static void randomAdd(List<Integer> list, String listType) {
            long t1 = System.currentTimeMillis();
            for (int i = 0; i < COUNT; i++) {
                list.add(ThreadLocalRandom.current().nextInt(0,COUNT), i);
            }
            long t2 = System.currentTimeMillis();
            System.out.println(listType + "随机位置插入" + COUNT + "次耗时：" + (t2-t1));
        }

        public static void main(String[] args) {

            randomAdd(fillList(new ArrayList<>(COUNT)), "数组");

            randomAdd(fillList(new LinkedList<>()), "链表");

        }

}
```
此时运行的结果为：
![COUNT为10000](https://camo.githubusercontent.com/0ec24c070b4f187b3c5c85bab0c1bb1d18f36fe98d31ddf3aa5ef873ddeea0c5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313136323630323232312d35643135333539342d353031382d343337372d383466312d6438303735376537323961352e706e67)

效果还不是很明显，我们将COUNT提升到100000，此时结果为：
![COUNT为100000](https://camo.githubusercontent.com/fddedb5e67a3330123d5b289f2064193716b6de9fac6f56de67bfe4397467151/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734313136323639313030362d63613766616134352d316436342d346635302d383661652d3830643834666266666531612e706e67)

可以得出为什么在实际开发中几乎不会使用LinkList。所以说呀，理想总是丰满的，现实总是骨感的😅。

