---
title: 图
icon: image
categories:
  - "408"
  - "数据结构"
  - "图"
---
## **图的基础**

> 定义：图G由顶点集V和边集E组成，记为 **G = (V, E)** ，其中 **V(G)** 表示图G中**顶点的有限非空集**； **E(G)** 表示图G种**边的集合**。若V={$v_1, v_2,...$}则|V|表示G中顶点的个数，E={(u, w)|u∈V,v∈V}，则|E|代表G中边的条数。

由上面的定义可知：图是不可以为空的，因为图的顶点集合是非空的。但边集可以为空，若边集为空则图中全是点，而没有点之间的关系。

## **图的术语**
### **有向图**
E为**有向边（又称弧）的有限集合，则图G为有向图。有向边是顶点的有序对**，记为<v, w>，其中v，w是顶点，v是弧尾，w是弧首，读作从v到w的弧，又称v邻接到w。

有向图在互相连接的节点之间只能以特定的方向移动。使用带单向箭头的线来表示有向边。
![有向图示意图](https://camo.githubusercontent.com/d5aabb2ca9b3fe7a393db4d028ee43138b1800813d3bc069d53e8c5a55d950de/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734323032343834393536352d61393934633534642d306666312d346232302d393836622d3866326532393139313230312e706e67)

### **无向图**
E为**无向边的有限集合，则图G为无向图。无向边是顶点的无序对**，记为(v, w)或(w, v)。v和w互为邻接点。边(v, w)依附于w和v，或称(v, w)和v，w相关联。

无向图可以在互相连接的节点之间可以以任意方向移动。
![无向图示意图](https://camo.githubusercontent.com/2c2d5c52c101f95a49677186a7924c6b9c01054e66be85fe9a2d180180a0639a/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734323032353631393934332d61396433366335612d666236312d343664312d396638322d6162616133616134323763312e706e67)

### **简单图、多重图**
图G满足：不存在重复的边；不存在顶点到自身的边，则称该图为简单图。多重图就是违背了上面的要求。

### **顶点的度、入度和出度**
这个要分有向图和无向图进行分析：
1. 无向图：讨论的是**度**，就是一个顶点上与多少顶点相连，其度就为多少。

2. 有向图：讨论的是**入度和出度**，入度是多少弧的弧首指向该顶点，出度是多少弧的弧尾在该顶点上。

除此之外，还要补充的是 **无向图的全部顶点的度之和等于边数的二倍**，因为一条边与两个顶点关联，多一条边就会多两个度。

**有向图全部顶点的入度之和与出度之和相等，并且分别等于边数。**
### **路径、路径长度和回路**
**对于不带权的图而言**，顶点$v_p 到 v_q$之间的一条路径是指的顶点序列，如：$v_p, v_{i1}, v_{i2}, ..., v_q$，路径中的相关联的边也可以作为路径的构成要素。

其中路径上经历的边的数量为**路径长度**。

**对于带权的图而言**，路径长度为路径$v_p, v_{i1}, v_{i2}, ..., v_q$上所有边上的权值之和。

若路径中的第一个顶点和最后一个顶点相同，则为一个**回路或环**。若一个图有n个顶点，且其边的数量大于n-1，则必定有环。
### **简单路径、简单回路**
重点是不重复。在路径序列中，顶点不重复出现的路径称为简单路径。除第一个和最后一个顶点外，其余顶点不重复出现的回路为简单回路。
### **距离**
顶点p到顶点q，若存在最短路径，则此路径的长度称为p到q的距离，否则记两定点距离为∞ 
### **子图**
$有两个图G=(V, E)和G^{'}=(V^{'}, E^{'})，若V^{'}是V的子集，且E^{'}是E的子集，则称G^{'}为G的子图。$

$假设满足V(G^{'}) = V(G)则称G^{'}为G的生成子图。$
:::important 注意
形成子图首先是两者都要为图，**所有并非V和E的任何子集都能构成G的子图**。如果取得E的子集中边含有的顶点在取得V的子集中没有，这样的话，图都构不成何谈**子图**呢！
:::
### **连通、连通图和连通分量**
这里的讨论是**针对无向图的**。假设无向图中的两个顶点v，w之间存在路径，则称v和w之间是**连通的**。若无向图中的任意两个顶点之间都是连通的，则称该图G为连通图，否则称为非连通图。

在无向图中的**极大连通子图**称为**连通分量**。

![示意图](https://camo.githubusercontent.com/4f9608660b480180195c7a66101dd058a1cd40373dd92bfbe5db36d0ad44b3ec/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323039323136373437332d63626137386232342d316333652d343530612d613035382d6638626434383136393232662e6a706567)

### **强连通图、强连通分量**
这里的讨论是**针对有向图的**。和上面的无向图类似，假设有向图中的两个顶点v，w之间相互都存在路径，则称两个顶点是**强连通的**。若有向图中的任意一对顶点都是强连通的，则称该图为强连通图。

有向图中的**极大强连通子图**称为该有向图的**强连通分量**。

:::tip tips
这里任意两个顶点之间路径并不是说每两个顶点之间存在相互的弧，而是说只要能到达就算，**所以一个图是强连通图时，其最少的边为n条，沿一个方向形成一个圈时使用的边最少**。
:::
### **生成树、生成森林**
**连通图**的生成树是包含图中所有顶点的一个**极小连通子图**（图连通但是要边数最小）。也就是说若一个图的顶点有n个，那该图的边就有n-1条。

对于一个生成树而言，若添加一条边就会形成回路，若减少一条边就会变得不再连通。

生成森林和生成树类似，就是图为**非连通图**，经历多次上面生成树的过程就生成了由多棵树组成的森林。

![生成树示意图](https://camo.githubusercontent.com/354c62fc83c76047ecc0f6a8c30a3e24e323bdde0a5a6312aec2eaf84c06e914/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6769662f34383037333733302f313734323137373530333230332d31333634356333642d356437302d343938302d616130622d3636326132393061313031312e676966)

显然可以看见生成树不止一种，只要满足上述的条件无论怎样生成都是合理的。
### **边的权、网和带权路径长度**
图的边上带有存在特殊意义的数值时，这个数值就称为该边的**权值**。边上带权的图就称为**网**。一条路径上所有边的权值之和称为该路径的**带权路径长度（路径长度）**。

![网的示意图](https://camo.githubusercontent.com/a942cf03f199c680c1310b362855d8b1057f9bc52a4a261fd2e3b32271d4afe2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734323137383938313730302d38336561323633352d316366382d343264662d613732652d3133313532326635383566372e706e67)

### **完全图**
无论是有向图还是无向图，其完全图都是边最多的情况。也就是任意两个顶点之间都存在边（弧）。

对于**无向图**，因为(v, w)和(w, v)是一致的，故其完全图（无向完全图）的边有$\frac {n(n - 1)}{2}$条。

对于**有向图**，因为<v, w>和<w, v>是不同的，故其完全图（有向完全图）的弧有$n(n - 1)$条。
### **稠密图、稀疏图**
对于图而言的稠密和稀疏是针对**边数和顶点个数的关系**。

一般而言，若图的$|E| < |V|log_2{|V|}$，则称该图为稀疏图（就是边数相对于顶点数太少了）。
### **有向树**
有**一个入度为0**的顶点并且**其余顶点的入度均为1**的**有向图**，该图被认为是一颗有向树。

![有向树示意图](https://camo.githubusercontent.com/b8177ba3128d10dfee89f3c631f1a4095453ede27f691df611b1b4796ac1e720/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734323137383738363539392d62343361393436342d353330312d346562352d616635362d3162643933373665333137382e706e67)

## **图的存储和基本操作**
图的存储需要详细保存**顶点集**和**边集**。我们需要掌握一下四种表示方法。
### **邻接矩阵法**
采用一个一维数组对图的顶点信息进行维护，一个二维数组对图的边信息进行维护。该二维数组称为**邻接矩阵**。

若图G=(V, E)中有n个顶点，则邻接矩阵A为n x n的，将G中的顶点编号为$v_1, v_2, ..., V_n$，则有：

$$
A[i][j] =
\begin{cases}
1, & \text{若 } (v_i, v_j) \text{ 或 } \langle v_i, v_j \rangle \text{ 是 } E(G) \text{ 中的边} \\
0, & \text{若 } (v_i, v_j) \text{ 或 } \langle v_i, v_j \rangle \text{ 不是 } E(G) \text{ 中的边}
\end{cases}
$$

而对于带权图而言，对应的$A[i][j]$位置上存放具体的**权值**。而没有边（弧）的$A[i][j]$存放0或者∞则可。

![各种图的邻接表转换](https://camo.githubusercontent.com/5dbedcb2f7bf6e472cbfa3b440f132970c6d7a6fe04927e65c8a19261d8d6d62/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323138303431353036342d64643764313938652d636631302d343837322d623766642d6538356161303764326533322e6a706567)

使用C语言表示的结构体为：
```c

```
:::tip 小贴士
- 无向图的邻接矩阵是对称矩阵，故在存储时可以采用压缩存储。
- 邻接矩阵表示法的空间复杂度为O($|V|^2$)。
- 如果是简单的应用则可以直接省略顶点信息，只使用邻接矩阵。
:::

图的邻接矩阵表示法的特点：

1. 无向图的邻接矩阵为**对称矩阵**，故存储时只需使用$\frac {n(n + 1)}{2}$个元素的顺序表。

2. 无向图的邻接矩阵中，第i行（列）非零元素的个数为顶点i的度 TD($v_i$)。

3. 有向图的邻接矩阵中，第i行的非零元素个数为顶点i的出度OD($v_i$)，第i列的非零元素个数为顶点i的入度ID($v_i$)。

4. 邻接矩阵表示法可以很容易得出两个顶点之间是否存在边（弧），但是如果需要知道到底有多少条边就需要一次遍历每行每列了。

5. 稠密图是适用于邻接矩阵法表示。
### **邻接表法**

### **十字链表**

### **邻接多重**

### **基本操作**

## **图的应用**
### **最小生成树**
对于一个带权连通无向图，生成树不同，其树的权（树中的所有边的权值之和）也会有所不同。而其中**权最小的树**就为最小生成树（MST）。

有两种不同的算法：

#### **1. Prim算法**
开始时从图中任取一个顶点，加入到树T中，此时T中就只有一个顶点，然后**选择T中顶点上权值最小的边（所有T中所有没有使用过的边）**，得到**该边**和**与之对应的顶点**并将该顶点和对应的边加入T中，依次类推，直到所有的顶点全部加入。

这样得到的生成树T就为最小生成树。

![Prim算法示例](https://camo.githubusercontent.com/ffbeb1195921196f23c8a54e9be7521d78979bb4306244c8d41b511c3fd2edd3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323139323731393438342d64396232346261652d613431362d346334642d623530652d3463653462326132373836302e6a706567)

其时间复杂度为O($|V|^2$)，是与边无关的，所以**适用于求边稠密的图的最小生成树。**
#### **2. Kruskal算法**
按照边上权值递增的方式进行构造最小生成树。

开始时将图视为有n个无边的顶点G = {V, {}}，从所有边集中选出最小且未使用的边，若将边加上后不会形成环则加入边，否则选择下一条边。

![Kruskal算法示例](https://camo.githubusercontent.com/6c77f5f49f0ff32ab6876ae70fd6bd7a93ed1e47b1444ae4a9edbd67259423a6/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f6a7065672f34383037333733302f313734323239313430323631362d64626661343333372d313135652d343663342d393638622d3836663431613161623834612e6a706567)

其时间复杂度为O($|E|log_2|E|$)，是与点无关的，所以**适用于求点稠密的图的最小生成树。**

:::important 注意
对于Prim和Kruskal算法，都只适用于求带权连通**无向图**的生成子树。

因为在带权有向图中没有带权有向图的概念。
:::

### **最短路径**
在之前学的**广度优先搜索查找最短路径**是对于**无权图**的。在这里可以是**带权图**，把从一个顶点$v_0$到图中的其他任意一个顶点$v_i$的**一条路径所经过边上的权值之和**定义为**该路径的带权路径长度**，把带权路径长度最短的那条路径称为**最短路径**。

其实之前的无向图可以视为**每条边权值为1**的带权完全图。经历一次广度优先搜索就可以知道每个顶点到开始搜索的顶点的最短路径了，就像是从开始搜索的顶点向外的**波**。

而对于带权图的最短路径问题可以分为两类：

1. 求图中某一顶点到其余顶点的最短路径，使用Dijkstra算法。

2. 求图中任意两顶点之间的最短路径，使用Floyd算法。

#### **Dijkstra算法**
大名鼎鼎的GPS就是使用的这个算法来寻找当前位置到目标位置的最短路径，是**贪心算法的典型应用。**

总的来说，Dijkstra算法的原理为：

- 该算法会从**源节点**开始，寻找其他节点与该节点之间的最短路径。

- 该算法会记录其他节点到源节点的最短路径长度，并在寻找到更短路径长度时更新。

- 一旦找到了源节点到其他节点$A_i$之间的最短路径，则将$A_i$标记为已访问并添加到路径中。

- 重复上述过程直到所有节点都已访问。

Dijkstra算法实现：

设置一个集合S记录已求得最短路径的顶点，初始化时将源点$v_0$放入S中。

Dijkstra算法要实现需要几个辅助数组：

- final[] (标记各顶点是否已经找到最短路径，$v_i$找到了则令final[i]为true并将其加入S)

- dist[] (记录从源点$v_0$到其他顶点当前的最短路径长度，初始规则为：若从$v_0$到$v_i$有边（弧），则dist[i]为对应的权值，否则置为∞)

- path[] (path[i]表示从源点到顶点i之间i的最短路径的前驱节点，可以根据path[i]一步一步的找到前一个节点从而得到完整的最短路径)

步骤（通俗易懂版，在上面的三个数组中最为重要的就是 **dist[]** 所以我们在这**不讨论其余两个数组**）：

带权有向图G采用邻接矩阵 $arcs[i][j]$ 表示。

1. 初始化S、dist[]，将源点$v_0$加入到S中，$dist[i] = arcs[0][i]$。

2. 

3. 

Dijkstra算法只能用于**权值为正**的图中，若图中存在权值为负的边则该算法就不起作用了，并且**不论图采用何种方式存储其时间复杂度都为O($|V|^2$)。**
#### **Floyd算法**
Dijkstra算法是求的源点到其余顶点之间的最短路径，格局小了，Floyd算法直接搂每队顶点之间的最短路径。


Floyd算法是**允许边（弧）上的权值带有负值的**，但是**不能有回路**，其时间复杂度为O($|V|^3$)。其实也是可以使用Dijkstra算法求每队顶点之间的最短路径问题，只需要对每个顶点都使用一次Dijkstra算法就可，其时间复杂度为O($|V|^2|V|$)，和Floyd算法一致。
### **有向无环图描述表达式**
> 定义：若一个有向图中不存在环，则称为有向无环图，简称为DAG图。
### **拓扑排序**
> **AOV网：** 若用有向无环图表示一个工程，其顶点表示活动，用有向边$<v_i, v_j>$表示活动$v_i$必须先于活动$v_j$进行的关系，则将这种有向图称为**顶点表示活动的网络**，简称AOV网。

> **拓扑排序：** 是对**有向无环图**的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中B出现在A的后面。

拓扑排序就是对AOV网活动的顺序的一种排序，通俗的讲就是**按活动可能发生的顺序排序**，所以一个AOV网可能存在多个拓扑排序（活动发生的顺序不一定有具体的先后关系）。

更为详细的拓扑排序算法步骤：

1. 从AOV网中选择一个入度为0的顶点并输出。

2. 从AOV网中删除所有与**以选择的顶点为起点的有向边**。

3. 重复1、2步骤直到AOV网中为空或不存在入度为0的情况（没有入度为0的话，该图一定存在环，就不属于DAG了）。

![拓扑排序示例图](https://camo.githubusercontent.com/ee6763bec121f86d84d82c6a9de4a005255c3180c7714445636895d4bb291f8e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032352f706e672f34383037333733302f313734323335323531373739322d61393635393937342d643533662d346330632d613831372d3032623033376439613031382e706e67)

拓扑排序算法的C语言表示：
```c

```
因为拓扑排序在删除顶点后还会删除以该顶点为起点的边（相当于要遍历一次图），所以**图采用不同的存储结构会有不同的时间复杂度**。

若采用邻接矩阵表示法则时间复杂度为O($|V|^2$)。

若采用邻接表表示法则时间复杂度为O(|V| + |E|)。
### **关键路径**
> AOE网：在**带权有向图**中，以顶点表示**事件**，以有向边表示**活动**，以边上的权值表示**完成该活动的消耗（时间）**，称之为用边表示活动的网络，简称AOE网。

对于AOE网和AOV网，两者都是**DAG图**，但是前者边上有**权值**，后者没有，并且图中组成元素表示的含义也不同。

AOE网具有的性质：

- 只有在某顶点表示的**事件**发生后，从该顶点出发的各有向边代表的**活动才能开始**。

- 只有在进入某顶点的所有有向边代表的活动都结束时，该顶点代表的事件才能发生。

- AOE网仅有一个入度为0的顶点，称其为**源点（开始顶点）**，表示工程的开始；仅有一个出度为0的顶点，称其为**汇点（结束顶点）**，表示工程的结束。

> 关键路径、关键活动：从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，在关键路径上的活动称为关键活动。

:::important 注意
在带权图中的最大、最小路径长度是由所有路径中边上的权值之和大小决定的。路径MAX中边上的权值之和最大，则称MAX为具有最大路径长度的路径，反之亦然。
:::

在这里认为AOE图中边上的权值指的是活动需要消耗的时间，则整个工程完成所需最短时间是关键路径的长度，也就是说**工程完成所需的最短时间由关键路径上的活动消耗时间决定**。

所以我们要掌握的重点就是怎样找到关键活动（边）。只要关键活动找到了，关键路径和最短完成时间就都有了。

:::tip 注意
如果只是用人眼看，一下就可以找到关键路径，我们要掌握的是**算法思想**。
:::

为了找出关键活动，引入5个要使用的**参量**：


