"use strict";(self.webpackChunktechnology_life_blog=self.webpackChunktechnology_life_blog||[]).push([[7327],{6262:(t,e)=>{e.A=(t,e)=>{const o=t.__vccOpts||t;for(const[t,a]of e)o[t]=a;return o}},6902:(t,e,o)=>{o.r(e),o.d(e,{comp:()=>n,data:()=>r});var a=o(641);const i={},n=(0,o(6262).A)(i,[["render",function(t,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<h2 id="树形查找" tabindex="-1"><a class="header-anchor" href="#树形查找"><span>树形查找</span></a></h2><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h3><p>为什么会引入红黑树呢？因为在对AVL树进行插入或删除后，为了维持AVL树的平衡性，可能会进行频繁地调整</p><p><strong>整棵树</strong>的拓扑结构，为了减少代价，故引入红黑树这个在AVL树基础上放宽了条件的数据结构。</p><blockquote><p>满足一下条件的<strong>二叉排序树</strong>为红黑树。</p><ul><li>每个节点要么是黑色要么是红色的</li><li>根节点是黑色的</li><li>叶节点（虚构的外部节点、NULL节点）都是黑色的</li><li>不存在两个相邻的红节点（红节点的父节点和孩子节点都为黑色）</li><li>对于每个节点，从该节点到任意一个叶节点的简单路径上，所包含的黑色节点数相同</li></ul></blockquote>',5)]))}]]),r=JSON.parse('{"path":"/cs-basic/data-structure/search-algorithm.html","title":"查找算法","lang":"zh-CN","frontmatter":{"title":"查找算法","icon":"magnifying-glass","categories":["408","算法","查找算法"],"description":"树形查找 红黑树 为什么会引入红黑树呢？因为在对AVL树进行插入或删除后，为了维持AVL树的平衡性，可能会进行频繁地调整 整棵树的拓扑结构，为了减少代价，故引入红黑树这个在AVL树基础上放宽了条件的数据结构。 满足一下条件的二叉排序树为红黑树。 每个节点要么是黑色要么是红色的 根节点是黑色的 叶节点（虚构的外部节点、NULL节点）都是黑色的 不存在两个...","head":[["meta",{"property":"og:url","content":"https://github.com/amatureemoprince/cs-basic/data-structure/search-algorithm.html"}],["meta",{"property":"og:site_name","content":"Java咖啡馆"}],["meta",{"property":"og:title","content":"查找算法"}],["meta",{"property":"og:description","content":"树形查找 红黑树 为什么会引入红黑树呢？因为在对AVL树进行插入或删除后，为了维持AVL树的平衡性，可能会进行频繁地调整 整棵树的拓扑结构，为了减少代价，故引入红黑树这个在AVL树基础上放宽了条件的数据结构。 满足一下条件的二叉排序树为红黑树。 每个节点要么是黑色要么是红色的 根节点是黑色的 叶节点（虚构的外部节点、NULL节点）都是黑色的 不存在两个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-26T00:41:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-26T00:41:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"查找算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-26T00:41:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"阿杰 like coding bug ❥\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"git":{"createdTime":1740981411000,"updatedTime":1742949692000,"contributors":[{"name":"lj","username":"lj","email":"2069057986@qq.com","commits":3,"url":"https://github.com/lj"}]},"readingTime":{"minutes":0.74,"words":223},"filePathRelative":"cs-basic/data-structure/search-algorithm.md","localizedDate":"2025年3月3日","excerpt":"<h2>树形查找</h2>\\n<h3>红黑树</h3>\\n<p>为什么会引入红黑树呢？因为在对AVL树进行插入或删除后，为了维持AVL树的平衡性，可能会进行频繁地调整</p>\\n<p><strong>整棵树</strong>的拓扑结构，为了减少代价，故引入红黑树这个在AVL树基础上放宽了条件的数据结构。</p>\\n<blockquote>\\n<p>满足一下条件的<strong>二叉排序树</strong>为红黑树。</p>\\n<ul>\\n<li>每个节点要么是黑色要么是红色的</li>\\n<li>根节点是黑色的</li>\\n<li>叶节点（虚构的外部节点、NULL节点）都是黑色的</li>\\n<li>不存在两个相邻的红节点（红节点的父节点和孩子节点都为黑色）</li>\\n<li>对于每个节点，从该节点到任意一个叶节点的简单路径上，所包含的黑色节点数相同</li>\\n</ul>\\n</blockquote>","autoDesc":true}')}}]);