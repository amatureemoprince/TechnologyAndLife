"use strict";(self.webpackChunktechnology_life_blog=self.webpackChunktechnology_life_blog||[]).push([[7327],{6262:(a,s)=>{s.A=(a,s)=>{const t=a.__vccOpts||a;for(const[a,e]of s)t[a]=e;return t}},9928:(a,s,t)=>{t.r(s),t.d(s,{comp:()=>p,data:()=>l});var e=t(641);const n={},p=(0,t(6262).A)(n,[["render",function(a,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h2 id="树形查找" tabindex="-1"><a class="header-anchor" href="#树形查找"><span>树形查找</span></a></h2><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h3><p>为什么会引入红黑树呢？因为在对AVL树进行插入或删除后，为了维持AVL树的平衡性，可能会进行频繁地调整</p><p><strong>整棵树</strong>的拓扑结构，为了减少代价，故引入红黑树这个在AVL树基础上放宽了条件的数据结构。</p><blockquote><p>满足一下条件的<strong>二叉排序树</strong>为红黑树。</p><ul><li>每个节点要么是黑色要么是红色的</li><li>根节点是黑色的</li><li>叶节点（虚构的外部节点、NULL节点）都是黑色的</li><li>不存在两个相邻的红节点（红节点的父节点和孩子节点都为黑色）</li><li>对于每个节点，从该节点到任意一个叶节点的简单路径上，所包含的黑色节点数相同</li></ul></blockquote><h3 id="红黑树的插入" tabindex="-1"><a class="header-anchor" href="#红黑树的插入"><span>红黑树的插入</span></a></h3><h3 id="红黑树的删除" tabindex="-1"><a class="header-anchor" href="#红黑树的删除"><span>红黑树的删除</span></a></h3><h3 id="b树" tabindex="-1"><a class="header-anchor" href="#b树"><span>B树</span></a></h3><p>B树的创始人也没有明确表示为什么要将这个数据结构命名为B树。</p><p>可以这样认为：还是为了保证Balance-平衡！在工业生产上这是很重要的。因为一秒的差距影响的就是真金白银。MySql的底层InnoDB就是采用的B树的变体<strong>B+树</strong>。</p><p>B树及其变体广泛应用于需要高效磁盘访问的场景，如数据库索引和文件系统。</p><blockquote><p>定义：一颗m阶B树或为空树，或满足以下特性的m叉树。</p><ul><li>树中的每个节点最多有 ⌈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>m</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\\frac{m}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>⌉</li></ul></blockquote><p>所谓m阶B树是所有节点的<strong>平衡因子都为0</strong>的m路平衡查找树</p><h3 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树"><span>B+树</span></a></h3>',14)]))}]]),l=JSON.parse('{"path":"/cs-basic/data-structure/search-algorithm.html","title":"查找算法","lang":"zh-CN","frontmatter":{"title":"查找算法","icon":"magnifying-glass","categories":["408","算法","查找算法"],"description":"树形查找 红黑树 为什么会引入红黑树呢？因为在对AVL树进行插入或删除后，为了维持AVL树的平衡性，可能会进行频繁地调整 整棵树的拓扑结构，为了减少代价，故引入红黑树这个在AVL树基础上放宽了条件的数据结构。 满足一下条件的二叉排序树为红黑树。 每个节点要么是黑色要么是红色的 根节点是黑色的 叶节点（虚构的外部节点、NULL节点）都是黑色的 不存在两个...","head":[["meta",{"property":"og:url","content":"https://github.com/amatureemoprince/cs-basic/data-structure/search-algorithm.html"}],["meta",{"property":"og:site_name","content":"Java咖啡馆"}],["meta",{"property":"og:title","content":"查找算法"}],["meta",{"property":"og:description","content":"树形查找 红黑树 为什么会引入红黑树呢？因为在对AVL树进行插入或删除后，为了维持AVL树的平衡性，可能会进行频繁地调整 整棵树的拓扑结构，为了减少代价，故引入红黑树这个在AVL树基础上放宽了条件的数据结构。 满足一下条件的二叉排序树为红黑树。 每个节点要么是黑色要么是红色的 根节点是黑色的 叶节点（虚构的外部节点、NULL节点）都是黑色的 不存在两个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-28T07:58:52.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-28T07:58:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"查找算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-28T07:58:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"阿杰 like coding bug ❥\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"git":{"createdTime":1740981411000,"updatedTime":1743148732000,"contributors":[{"name":"lj","username":"lj","email":"2069057986@qq.com","commits":4,"url":"https://github.com/lj"}]},"readingTime":{"minutes":1.41,"words":424},"filePathRelative":"cs-basic/data-structure/search-algorithm.md","localizedDate":"2025年3月3日","excerpt":"<h2>树形查找</h2>\\n<h3>红黑树</h3>\\n<p>为什么会引入红黑树呢？因为在对AVL树进行插入或删除后，为了维持AVL树的平衡性，可能会进行频繁地调整</p>\\n<p><strong>整棵树</strong>的拓扑结构，为了减少代价，故引入红黑树这个在AVL树基础上放宽了条件的数据结构。</p>\\n<blockquote>\\n<p>满足一下条件的<strong>二叉排序树</strong>为红黑树。</p>\\n<ul>\\n<li>每个节点要么是黑色要么是红色的</li>\\n<li>根节点是黑色的</li>\\n<li>叶节点（虚构的外部节点、NULL节点）都是黑色的</li>\\n<li>不存在两个相邻的红节点（红节点的父节点和孩子节点都为黑色）</li>\\n<li>对于每个节点，从该节点到任意一个叶节点的简单路径上，所包含的黑色节点数相同</li>\\n</ul>\\n</blockquote>","autoDesc":true}')}}]);