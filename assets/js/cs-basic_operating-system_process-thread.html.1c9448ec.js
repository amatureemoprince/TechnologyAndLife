"use strict";(self.webpackChunktechnology_life_blog=self.webpackChunktechnology_life_blog||[]).push([[1634],{4518:(r,t,e)=>{e.r(t),e.d(t,{comp:()=>o,data:()=>p});var b=e(641);const a={},o=(0,e(6262).A)(a,[["render",function(r,t){return(0,b.uX)(),(0,b.CE)("div",null,t[0]||(t[0]=[(0,b.Fv)("<p>进程与线程<br> CPU 调度<br> 先来先服务（FCFS）调度算法<br> 短作业优先（SJF）调度算法<br> 高响应比优先调度算法<br> 优先级调度算法<br> 时间片轮转（RR）调度算法<br> 多级队列调度算法<br> 多级反馈队列调度算法<br> 基于公平原则的调度算法<br> 多处理机调度<br> 同步与互斥<br> 同步与互斥的基本概念<br> 在多道程序环境中，进程是并发执行的，不同进程之间存在着不同的相互制约关系，进程之间执行顺序可能不同，同步要保证某些进程一定要发生在另一些进程之前，也就是要有执行的顺序。<br> 对于某些计算机资源，进程之间是不能同时访问的（如：打印机），互斥就是要保证这点。<br> 这一节核心就是同步和互斥机制的实现和运用。</p><p>临界资源<br> 一次只允许一个进程访问的资源称为临界资源。<br> 对于临界资源，进程必须互斥地进行访问，在每个进程中，访问临界资源的那段代码称为临界区。<br> 对临界资源的访问过程可以划分为 4 个部分：<br> ● 进入区<br> ● 临界区<br> ● 退出区<br> ● 剩余区</p><p>同步<br> 又称直接制约关系。<br> 指为了完成某种任务而建立的两个或多个进程，这些进程因为需要协调它们的运行次序而等待、传递信息所产生的制约关系。<br> 著名的“生产者-消费者问题”就是一个同步问题。</p><p>互斥<br> 又称间接制约关系。<br> 当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进行退出临界区后，另一个进程才能去访问此临界资源。<br> 两个进程都需要使用“打印机”这个临界资源，但是只有一台打印机，当 A 进程在使用时，B 就不能去使用，只有当 A 释放了“打印机”资源，B 才能去使用。</p><p>为了禁止两个进程同时进入临界区，同步机制应该满足以下准则：<br> ● 空闲让进<br> ● 忙则等待<br> ● 让权等待（不是必须，原则上应遵循）<br> ● 有限等待</p><p>实现临界区互斥的基本方法<br> 软件实现<br> 因为是“软件实现”，那肯定为设置“变量”来达到目的撒（实际上也确实如此）。<br> 通过设置一些“标志”来表明是否有进程进入临界区中，若有则其他进程在进入区通过循环检测进行等待，直到进入到临界区的进程在退出区修改“标志”，否则直接进入。<br> wjegghewoi<br> 单标志法<br> 主要用于两个进程之间的互斥访问临界资源。<br> 使用一个 tag 变量作为标志，若 tag=0 则 P0 进程可以使用临界资源，若 tag=1 则 P1 进程可以使用临界资源。<br> int tag = 0;<br> P0(){<br> while(tag != 0){<br> };<br> 临界区代码;<br> tag = 1;<br> 剩余区代码;<br> }<br> P1(){<br> while(tag != 1){<br> };<br> 临界区代码;<br> tag = 0;<br> 剩余区代码;<br> }<br> 对于单标志法，虽然简单，但有着巨大的缺陷。设想一下，如果 P0 顺利的执行并离开，那此时的临界资源是空闲的，但 P1 不再使用这个临界资源，则 tag=1 一直都成立，P0 也就无法再执行临界区代码了（两个进程必须交替的进入临界区，P0 执行了 P1 执行，P1 执行了 P0 执行，往复循环）。<br> 这样违背了“空闲让进”准则，在实际生产中很少使用。</p><p>双标志先检查法<br> 通过设置可以表示两个信号的 tag 标志进行互斥访问。<br> tag[0] 为 true 则表示 P0 想进入临界区，另一个同理。P0 先判断 P1 是否想进入临界区，并且在进入临界区之前将自己设置为想进入临界区，这样就算切换到 P1，P1 也不会进入临界区，在 P0 执行完临界区代码后设置自己不想访问临界区，这样 P1 就可以进行访问了。<br> bool tag[2];<br> P0(){<br> while(tag[1]){<br> };<br> tag[0] = true;<br> 临界区代码;<br> tag[0] = false;<br> 剩余区代码;<br> }<br> P1(){<br> while(tag[0]){<br> };<br> tag[1] = true;<br> 临界区代码;<br> tag[1] = false;<br> 剩余区代码;<br> }<br> 这样的设计使得进程之间不用交替使用，但是 P0 和 P1 可能同时进入临界区，P0 在执行 while 循环后切换到了 P1，因为 P1 没有设置自己想访问临界区所以 P1 也可以通过 while 循环，这样 P0，P1 两个进程就同时进入了临界区，违背了“忙则等待”准则。<br> 这里的核心痛点是：while 判断和设置不能一气呵成，导致其他进程可以“趁虚而入”。</p><p>双标志后检查法</p><p>Peterson 算法</p><p>硬件实现<br> 互斥锁<br> 信号量<br> 经典同步问题<br> 生产者-消费者问题<br> 多生产者-多消费者问题<br> 吸烟者问题<br> 读者-写者问题<br> 哲学家进餐问题<br> 管程<br> 死锁</p>",10)]))}]]),p=JSON.parse('{"path":"/cs-basic/operating-system/process-thread.html","title":"","lang":"zh-CN","frontmatter":{"description":"进程与线程 CPU 调度 先来先服务（FCFS）调度算法 短作业优先（SJF）调度算法 高响应比优先调度算法 优先级调度算法 时间片轮转（RR）调度算法 多级队列调度算法 多级反馈队列调度算法 基于公平原则的调度算法 多处理机调度 同步与互斥 同步与互斥的基本概念 在多道程序环境中，进程是并发执行的，不同进程之间存在着不同的相互制约关系，进程之间执行顺...","head":[["meta",{"property":"og:url","content":"https://github.com/amatureemoprince/cs-basic/operating-system/process-thread.html"}],["meta",{"property":"og:site_name","content":"Java咖啡馆"}],["meta",{"property":"og:description","content":"进程与线程 CPU 调度 先来先服务（FCFS）调度算法 短作业优先（SJF）调度算法 高响应比优先调度算法 优先级调度算法 时间片轮转（RR）调度算法 多级队列调度算法 多级反馈队列调度算法 基于公平原则的调度算法 多处理机调度 同步与互斥 同步与互斥的基本概念 在多道程序环境中，进程是并发执行的，不同进程之间存在着不同的相互制约关系，进程之间执行顺..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-24T14:09:46.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-24T14:09:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-24T14:09:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"阿杰 like coding bug ❥\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"git":{"createdTime":1745413386000,"updatedTime":1745503786000,"contributors":[{"name":"lj","username":"lj","email":"2069057986@qq.com","commits":2,"url":"https://github.com/lj"}]},"readingTime":{"minutes":4.36,"words":1307},"filePathRelative":"cs-basic/operating-system/process-thread.md","localizedDate":"2025年4月23日","excerpt":"<p>进程与线程<br>\\nCPU 调度<br>\\n先来先服务（FCFS）调度算法<br>\\n短作业优先（SJF）调度算法<br>\\n高响应比优先调度算法<br>\\n优先级调度算法<br>\\n时间片轮转（RR）调度算法<br>\\n多级队列调度算法<br>\\n多级反馈队列调度算法<br>\\n基于公平原则的调度算法<br>\\n多处理机调度<br>\\n同步与互斥<br>\\n同步与互斥的基本概念<br>\\n在多道程序环境中，进程是并发执行的，不同进程之间存在着不同的相互制约关系，进程之间执行顺序可能不同，同步要保证某些进程一定要发生在另一些进程之前，也就是要有执行的顺序。<br>\\n对于某些计算机资源，进程之间是不能同时访问的（如：打印机），互斥就是要保证这点。<br>\\n这一节核心就是同步和互斥机制的实现和运用。</p>","autoDesc":true}')},6262:(r,t)=>{t.A=(r,t)=>{const e=r.__vccOpts||r;for(const[r,b]of t)e[r]=b;return e}}}]);